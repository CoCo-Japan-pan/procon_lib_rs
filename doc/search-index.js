var searchIndex = JSON.parse('{\
"algebra":{"doc":"<code>Algrebra</code>…","t":"QIIIIIQIIQQQKKKKKKKKKK","n":["A","Action","ActionMonoid","Commutative","Group","IdempotentMonoid","M","Monoid","Semiring","Target","Target","Target","add_assign","apply","binary_operation","composition","id_action","id_element","inverse","mul","one","zero"],"q":[[0,"algebra"]],"d":["作用素のモノイド","作用 作用自体もモノイドであることを要求 …","自己準同型性を要求 …","可換  ","群 モノイドに加えて、逆元を持つ  ","冪等なモノイド つまり x = x op x …","作用の対象のモノイド","モノイド","半環 加算は可換モノイド 乗算はモノイド …","作用の対象","モノイドの要素","","","作用の適用","二項演算","作用の合成(selfが先、rhsが後) (atcoder …","恒等写像","単位元","","","",""],"i":[1,0,0,0,0,0,1,0,0,2,3,4,4,2,3,2,2,3,5,4,4,4],"f":[0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]]],"c":[],"p":[[8,"ActionMonoid"],[8,"Action"],[8,"Monoid"],[8,"Semiring"],[8,"Group"]]},\
"auxiliary_tree":{"doc":"LCAベースの圧縮木 Auxiliary Tree","t":"DLLMLLLLLLLL","n":["AuxiliaryTree","borrow","borrow_mut","euler_tour","fmt","from","gen_auxiliary_tree","into","new","try_from","try_into","type_id"],"q":[[0,"auxiliary_tree"]],"d":["","","","","","Returns the argument unchanged.","LCAの関係を保ったまま圧縮された木を返す …","Calls <code>U::from(self)</code>.","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],0,[[1,2],3],[[]],[[1,[5,[4]]]],[[]],[4,1],[[],6],[[],6],[[],7]],"c":[],"p":[[3,"AuxiliaryTree"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"avl":{"doc":"AVL木 <code>std::collections::BTreeSet</code> …","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["AVL","Iter","append","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","contains","count","erase","erase_by_index","fmt","fmt","from","from","get","height","insert","insert_by_index","into","into","into_iter","into_vec","is_empty","iter","len","lower_bound","new","next","rotate_left","rotate_right","split_off","to_owned","to_string","try_from","try_from","try_into","try_into","type_id","type_id","upper_bound"],"q":[[0,"avl"]],"d":["","","…","","","","","","","","","二分探索で値を見つけて一つ削除","","","","Returns the argument unchanged.","Returns the argument unchanged.","index番目(0-base)の値を取得","","適切な順序を二分探索して挿入","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","重複を許すならtrue","","rangeの範囲においてkだけ左回転する …","rangeの範囲においてkだけ右回転する …","[0, index)を残し、[index, n)を返す","","","","","","","","",""],"i":[0,0,1,13,1,13,1,1,1,1,1,1,1,1,1,13,1,1,1,1,1,13,1,13,1,1,1,1,1,1,13,1,1,1,1,1,13,1,13,1,13,1,1],"f":[0,0,[[1,1]],[[]],[[]],[[]],[[]],[[[1,[2]]],[[1,[2]]]],[[]],[[[1,[3]],3],4],[[[1,[3]],3],5],[[[1,[3]],3],4],[[1,5],6],[[[1,[7]],8],9],[[[1,[10]],8],9],[[]],[[]],[[1,5],6],[1,11],[[[1,[3]],3]],[[1,5]],[[]],[[]],[[]],[1,12],[1,4],[1,13],[1,5],[[[1,[3]],3],5],[4,1],[13,6],[[1,[14,[5]],5]],[[1,[14,[5]],5]],[[1,5],1],[[]],[[],15],[[],16],[[],16],[[],16],[[],16],[[],17],[[],17],[[[1,[3]],3],5]],"c":[],"p":[[3,"AVL"],[8,"Clone"],[8,"PartialOrd"],[15,"bool"],[15,"usize"],[4,"Option"],[8,"Display"],[3,"Formatter"],[6,"Result"],[8,"Debug"],[15,"u8"],[3,"Vec"],[3,"Iter"],[8,"RangeBounds"],[3,"String"],[4,"Result"],[3,"TypeId"]]},\
"binom":{"doc":"…","t":"DLLLLLLLLLLLL","n":["Binom","borrow","borrow_mut","comb","from","get_fact","get_ifact","into","new","perm","try_from","try_into","type_id"],"q":[[0,"binom"]],"d":["","","","nCkの計算(n&lt;kの場合は0とする)","Returns the argument unchanged.","n!","n!の逆元","Calls <code>U::from(self)</code>.","","nPkの計算(n&lt;kの場合は0とする)","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[[[2,[1]],3,3],1],[[]],[[[2,[1]],3],1],[[[2,[1]],3],1],[[]],[3,[[2,[1]]]],[[[2,[1]],3,3],1],[[],4],[[],4],[[],5]],"c":[],"p":[[8,"ModInt"],[3,"Binom"],[15,"usize"],[4,"Result"],[3,"TypeId"]]},\
"bit_matrix":{"doc":"mod 2の世界での行列  ","t":"DIDDKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLL","n":["BitMatrix","BitMatrixOps","PlusOrMulAnd","PlusXorMulAnd","add","add","add","add","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","eq","eq","eq","fmt","fmt","fmt","from","from","from","from","from","from","from","gauss_jordan","get","index","into","into","into","linear_equation","mul","mul","mul","mul","new","pow","set","to_owned","to_owned","to_owned","transpose","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","unit"],"q":[[0,"bit_matrix"]],"d":["","","<code>+ = or, * = and</code>","<code>+ = xor, * = and</code>","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","","Returns the argument unchanged.","","…","indexでアクセスしてもよい","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","連立一次方程式 Ax = …","","","","","","行列のべき乗を計算する  ","","","","","","","","","","","","","","",""],"i":[0,0,0,0,14,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,1,1,1,1,1,1,1,2,3,1,1,14,2,3,1,1,1,1,2,3,1,1,2,3,1,2,3,1,2,3,1,1],"f":[0,0,0,0,[[1,1],1],[[1,1],1],[[1,1],1],[[1,1],1],[[]],[[]],[[]],[[]],[[]],[[]],[2,2],[3,3],[1,1],[[]],[[]],[[]],[[2,2],4],[[3,3],4],[[1,1],4],[[2,5],6],[[3,5],6],[[1,5],6],[[]],[[]],[[],1],[[[8,[7]]],1],[[],1],[[]],[[[8,[[8,[4]]]]],1],[[1,4]],[[1,9,9],4],[[1,9]],[[]],[[]],[[]],[1,10],[[1,1],1],[[1,1],1],[[1,1],1],[[1,1],1],[[9,9],1],[[1,11],1],[[1,9,9,4]],[[]],[[]],[[]],[1,1],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],13],[[],13],[[],13],[9,1]],"c":[],"p":[[3,"BitMatrix"],[3,"PlusOrMulAnd"],[3,"PlusXorMulAnd"],[15,"bool"],[3,"Formatter"],[6,"Result"],[3,"BitSet"],[3,"Vec"],[15,"usize"],[4,"Option"],[15,"u64"],[4,"Result"],[3,"TypeId"],[8,"BitMatrixOps"]]},\
"bitdict":{"doc":"完備辞書 2N + O(1) bit …","t":"DLLLLLLLLLLLLLLLLLLLLLL","n":["BitDict","access","borrow","borrow_mut","build","clone","clone_into","fmt","from","from","into","new","rank0_all","rank1_all","rank_0","rank_1","select_0","select_1","set","to_owned","try_from","try_into","type_id"],"q":[[0,"bitdict"]],"d":["","i番目のビットを取得する O(1)","","","…","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","0で初期化されたビット列を作成","全ての範囲における0の数 O(1)","全ての範囲における1の数 O(1)","[0..i)の0の数 O(1)","[0..i)の1の数 O(1)","0-basedでi番目の0の位置 最悪O(logN) 平均O(1)","0-basedでi番目の1の位置 最悪O(logN) 平均O(1)","i番目のビットを立てる …","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[1,2],3],[[]],[[]],[1],[1,1],[[]],[[1,4],5],[[]],[[],1],[[]],[2,1],[1,2],[1,2],[[1,2],2],[[1,2],2],[[1,2],[[6,[2]]]],[[1,2],[[6,[2]]]],[[1,2]],[[]],[[],7],[[],7],[[],8]],"c":[],"p":[[3,"BitDict"],[15,"usize"],[15,"bool"],[3,"Formatter"],[6,"Result"],[4,"Option"],[4,"Result"],[3,"TypeId"]]},\
"bitset":{"doc":"…","t":"DLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["BitSet","all","any","bitand","bitand","bitand_assign","bitor","bitor","bitor_assign","bitxor","bitxor","bitxor_assign","borrow","borrow_mut","buffer","buffer_mut","chomp","clone","clone_into","count_ones","count_zeros","eq","flip","fmt","from","from","from","get","hash","index","into","new","none","not","not","set","shl","shl","shl_assign","shl_or","shr","shr","shr_assign","shr_or","size","to_owned","try_from","try_into","type_id"],"q":[[0,"bitset"]],"d":["bitとしてはLSB -&gt; …","全て1かどうかを返す","どれか1つでも1があるかどうかを返す","","","","","","","","","","","","","","範囲外だが余分に持っているbitを0にする …","","","1の数を返す","0の数を返す","","i番目のbitを反転させる","","Returns the argument unchanged.","","","indexでアクセスしてもよい","","","Calls <code>U::from(self)</code>.","size個のbitを持つBitSetを生成する(どれもunset)","全て0かどうかを返す","","","i番目のbitをbに設定する","","","","Faster left shift and or","","","","Faster right shift and or","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[1,2],[1,2],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[]],[[]],[1],[1],[1],[1,1],[[]],[1,3],[1,3],[[1,1],2],[[1,4]],[[1,5],6],[[]],[[],1],[[[7,[2]]],1],[[1,4],2],[[1,8]],[[1,4],2],[[]],[4,1],[1,2],[1],[1,1],[[1,4,2]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[1,4],[[]],[[],9],[[],9],[[],10]],"c":[],"p":[[3,"BitSet"],[15,"bool"],[15,"u32"],[15,"usize"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[8,"Hasher"],[4,"Result"],[3,"TypeId"]]},\
"capture":{"doc":"From …","t":"OO","n":["crecurse","memorize"],"q":[[0,"capture"]],"d":["Macro that returns a recursive function that …","Automatic memorization for recursive functions."],"i":[0,0],"f":[0,0],"c":[],"p":[]},\
"cartesian_tree":{"doc":"Cartesian-tree …","t":"DLLLLLLLMLMMMLLLL","n":["CartesianTree","borrow","borrow_mut","clone","clone_into","fmt","from","into","left_child","new","parent","right_child","root","to_owned","try_from","try_into","type_id"],"q":[[0,"cartesian_tree"]],"d":["","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","…","","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,2],3],[[]],[[]],0,[4,1],0,0,0,[[]],[[],5],[[],5],[[],6]],"c":[],"p":[[3,"CartesianTree"],[3,"Formatter"],[6,"Result"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"centroid_decomposition":{"doc":"木の(再帰的な)重心分解を行う","t":"DLLLLLLLLLLL","n":["CentroidDecomposition","borrow","borrow_mut","calc_centroid_tree","from","get_centroid","into","new","run","try_from","try_into","type_id"],"q":[[0,"centroid_decomposition"]],"d":["","","","centroid-tree グラフが空の場合は(vec![], …","Returns the argument unchanged.","…","Calls <code>U::from(self)</code>.","","<code>f = |used: &amp;[bool], centroid: usize| { ... }</code> <code>used</code>…","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1],[[]],[[1,2],2],[[]],[[[3,[[3,[2]]]]],1],[[1,4]],[[],5],[[],5],[[],6]],"c":[],"p":[[3,"CentroidDecomposition"],[15,"usize"],[3,"Vec"],[8,"FnMut"],[4,"Result"],[3,"TypeId"]]},\
"cht_offline":{"doc":"Li Chao treeによるCHT i64型で収まる前提 ax + b …","t":"DIEELLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLKLL","n":["CHTOffline","Compare","MaxCompare","MinCompare","add_line","add_line_segment","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","fmt","fmt","fmt","from","from","from","get","identity","identity","identity","into","into","into","new","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","update","update","update"],"q":[[0,"cht_offline"]],"d":["最大値クエリの場合は<code>T = MaxCompare</code>…","…","","","直線<code>ax + b</code>を追加する","線分 <code>ax + b (xはrangeの範囲内で有効)</code> …","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","xにおける最小値または最大値を求める","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","lhsをrhsで更新するべきならtrue","",""],"i":[0,0,0,0,2,2,5,8,2,5,8,2,5,8,2,5,8,2,2,1,5,8,5,8,2,2,5,8,2,5,8,2,5,8,2,1,5,8],"f":[0,0,0,0,[[[2,[1]],3,3]],[[[2,[1]],3,3,[4,[3]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[5,6],7],[[8,6],7],[[[2,[[0,[9,1]]]],6],7],[[]],[[]],[[]],[[[2,[1]],3],3],[[],3],[[],3],[[],3],[[]],[[]],[[]],[[[10,[3]]],[[2,[1]]]],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],12],[[],12],[[],12],[[3,3],13],[[3,3],13],[[3,3],13]],"c":[],"p":[[8,"Compare"],[3,"CHTOffline"],[15,"i64"],[8,"RangeBounds"],[4,"MaxCompare"],[3,"Formatter"],[6,"Result"],[4,"MinCompare"],[8,"Debug"],[3,"Vec"],[4,"Result"],[3,"TypeId"],[15,"bool"]]},\
"convex_hull":{"doc":"","t":"DLLLFLLLLLLLLLLLLFLLLLLLLLLLMM","n":["Point","add","borrow","borrow_mut","calc_farthest_point_pair","clone","clone_into","cmp","cross","dot","eq","fmt","fmt","from","from","hash","into","monotone_chain","mul","new","partial_cmp","square_dist","sub","to_owned","to_string","try_from","try_into","type_id","x","y"],"q":[[0,"convex_hull"]],"d":["二次元座標を表す構造体","","","","…","","","","外積 これが0以上なら、self -&gt; rhs …","内積","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","ソート済みの点列から凸包を求める <code>O(n)</code> …","","","","(0, 0)からのユークリッド距離の二乗 <code>x^2 + y^2</code>","","","","","","","",""],"i":[0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[1,1]],[[]],[[]],[[],2],[1,1],[[]],[[1,1],3],[[1,1],2],[[1,1],2],[[1,1],4],[[1,5],[[7,[6]]]],[[1,5],[[7,[6]]]],[[]],[[],1],[[1,8]],[[]],[4],[[1,2]],[[2,2],1],[[1,1],[[9,[3]]]],[1,2],[[1,1]],[[]],[[],10],[[],7],[[],7],[[],11],0,0],"c":[],"p":[[3,"Point"],[15,"i64"],[4,"Ordering"],[15,"bool"],[3,"Formatter"],[3,"Error"],[4,"Result"],[8,"Hasher"],[4,"Option"],[3,"String"],[3,"TypeId"]]},\
"doubling":{"doc":"ダブリング  ","t":"DLLLLLLLLLLLLL","n":["Doubling","borrow","borrow_mut","clone","clone_into","fmt","from","into","new","query","to_owned","try_from","try_into","type_id"],"q":[[0,"doubling"]],"d":["","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","[0, n) -&gt; [0, n) の写像funcを受け取る …","func^x(index)を返す","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,2],3],[[]],[[]],[4,1],[[1,5,4],5],[[]],[[],6],[[],6],[[],7]],"c":[],"p":[[3,"Doubling"],[3,"Formatter"],[6,"Result"],[15,"u64"],[15,"usize"],[4,"Result"],[3,"TypeId"]]},\
"dual_segtree":{"doc":"作用素を通常のセグメント木のように持つ …","t":"DLLLLLLLLLLLLL","n":["DualSegTree","apply_range","apply_range_commutative","borrow","borrow_mut","fmt","from","get_composition","get_mapped","into","new","try_from","try_into","type_id"],"q":[[0,"dual_segtree"]],"d":["作用を区間適用, …","可換性を仮定しない作用の区間適用 …","区間に可換な作用を適用する …","","","","Returns the argument unchanged.","一点取得(その点への作用の合成を返す)","…","Calls <code>U::from(self)</code>.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]],[4,[3]],1]],[[[2,[[0,[1,5]]]],[4,[3]],[0,[1,5]]]],[[]],[[]],[[[2,[[0,[6,1]]]],7],8],[[]],[[[2,[1]],3],1],[[[2,[1]],3]],[[]],[3,[[2,[1]]]],[[],9],[[],9],[[],10]],"c":[],"p":[[8,"Action"],[3,"DualSegTree"],[15,"usize"],[8,"RangeBounds"],[8,"Commutative"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"TypeId"]]},\
"dynamic_modint":{"doc":"動的に決定するModを持つModInt …","t":"DILLLLLLLLOLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["DynamicModInt","ModContainer","add","add_assign","add_assign","borrow","borrow_mut","clone","clone_into","default","define_modcontainer","div","div_assign","div_assign","eq","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","from_str","get_static_modulus","hash","into","inv","modulus","modulus","modulus","mul","mul_assign","mul_assign","neg","new","new","one","pow","product","raw","raw","set_modulus","set_modulus","sub","sub_assign","sub_assign","sum","to_owned","to_string","try_from","try_into","type_id","value","value","zero"],"q":[[0,"dynamic_modint"]],"d":["","","","","","","","","","","ModContainerを定義するマクロ …","","","","","","","","","","","","","","Returns the argument unchanged.","","","","","","","","","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,0,[[[2,[1]]],[[2,[1]]]],[[[2,[1]],3]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[[2,[[0,[4,1]]]]],[[2,[[0,[4,1]]]]]],[[]],[[],[[2,[[0,[5,1]]]]]],0,[[[2,[1]]],[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]],3]],[[[2,[[0,[6,1]]]],[2,[[0,[6,1]]]]],7],[[[2,[1]],8],9],[[[2,[1]],8],9],[10,[[2,[1]]]],[11,[[2,[1]]]],[12,[[2,[1]]]],[13,[[2,[1]]]],[14,[[2,[1]]]],[15,[[2,[1]]]],[16,[[2,[1]]]],[[]],[17,[[2,[1]]]],[18,[[2,[1]]]],[19,[[2,[1]]]],[20,[[2,[1]]]],[21,[[2,[1]]]],[22,[[24,[[2,[1]],23]]]],[[],[[25,[17]]]],[[[2,[[0,[26,1]]]],27]],[[]],[[[2,[1]]],[[2,[1]]]],[[],17],[[],17],[[],17],[[[2,[1]]],[[2,[1]]]],[[[2,[1]],3]],[[[2,[1]],[2,[1]]]],[[[2,[1]]],[[2,[1]]]],[3,[[2,[1]]]],[3,[[2,[1]]]],[[],[[2,[1]]]],[[[2,[1]],21],[[2,[1]]]],[28,[[2,[1]]]],[17,[[2,[1]]]],[17,[[2,[1]]]],[17],[17],[[[2,[1]]],[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]],3]],[28,[[2,[1]]]],[[]],[[],29],[[],24],[[],24],[[],30],[[[2,[1]]],17],[[[2,[1]]],17],[[],[[2,[1]]]]],"c":[],"p":[[8,"ModContainer"],[3,"DynamicModInt"],[8,"RemEuclidU32"],[8,"Clone"],[8,"Default"],[8,"PartialEq"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"i64"],[15,"u128"],[15,"i32"],[15,"i16"],[15,"i8"],[15,"u8"],[15,"isize"],[15,"u32"],[15,"i128"],[15,"usize"],[15,"u16"],[15,"u64"],[15,"str"],[3,"ParseIntError"],[4,"Result"],[3,"OnceLock"],[8,"Hash"],[8,"Hasher"],[8,"Iterator"],[3,"String"],[3,"TypeId"]]},\
"enumerate_inv_mods":{"doc":"","t":"F","n":["enumerate_invs"],"q":[[0,"enumerate_inv_mods"]],"d":["n以下のmod逆元列挙を<code>O(n)</code>で行う index …"],"i":[0],"f":[[1,[[3,[2]]]]],"c":[],"p":[[15,"usize"],[8,"ModInt"],[3,"Vec"]]},\
"eratosthenes":{"doc":"エラトステネスの篩","t":"DLLLLLLLLLLLLLLLLL","n":["Eratosthenes","borrow","borrow_mut","divisor_mobius","divisor_zeta","enumerate_divisors","factorize","from","gcd_convolution","get_primes","into","is_prime","multiple_mobius","multiple_zeta","new","try_from","try_into","type_id"],"q":[[0,"eratosthenes"]],"d":["","","","…","約数関係に関する高速ゼータ変換 …","約数の個数オーダーで約数列挙 …","<code>O(log N)</code> で素因数分解 (素因数、べき) …","Returns the argument unchanged.","添え字gcd畳み込み …","","Calls <code>U::from(self)</code>.","","…","倍数関係に関する高速ゼータ変換 …","<code>O(NloglogN)</code> <code>max_n</code>以下の素数を求める","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[[1,[4,[[0,[2,3]]]]],[[4,[[0,[2,3]]]]]],[[1,[4,[3]],5],[[4,[3]]]],[[1,6],[[4,[6]]]],[[1,6],4],[[]],[1,[[4,[[0,[7,2,8,3]]]]]],[1],[[]],[[1,6],9],[[1,[4,[[0,[2,3]]]]],[[4,[[0,[2,3]]]]]],[[1,[4,[3]],5],[[4,[3]]]],[6,1],[[],10],[[],10],[[],11]],"c":[],"p":[[3,"Eratosthenes"],[8,"Sub"],[8,"Copy"],[3,"Vec"],[8,"Fn"],[15,"usize"],[8,"Add"],[8,"MulAssign"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"euler_tour":{"doc":"頂点に着目したオイラーツアー …","t":"DDLLLLLMMMLLLLLLLMLLLLLLLLL","n":["EulerTour","MinMonoid","binary_operation","borrow","borrow","borrow_mut","borrow_mut","depth","euler_tour_vertex","first_occurrence","fmt","fmt","from","from","id_element","into","into","last_occurrence","lca","lca_multiple","new","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"euler_tour"]],"d":["","","","","","","","各頂点の深さ","頂点に着目したオイラーツアー …","…","","","Returns the argument unchanged.","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","…","SparseTableを用いているので、<code>O(1)</code>","","SparseTableを構築しているので、<code>O(NlogN)</code>","","","","","",""],"i":[0,0,1,1,4,1,4,4,4,4,1,4,1,4,1,1,4,4,4,4,4,1,4,1,4,1,4],"f":[0,0,[[]],[[]],[[]],[[]],[[]],0,0,0,[[1,2],3],[[4,2],3],[[]],[[]],[[]],[[]],[[]],0,[[4,5,5],5],[4,5],[5,4],[[],6],[[],6],[[],6],[[],6],[[],7],[[],7]],"c":[],"p":[[3,"MinMonoid"],[3,"Formatter"],[6,"Result"],[3,"EulerTour"],[15,"usize"],[4,"Result"],[3,"TypeId"]]},\
"eulerian_trail":{"doc":"オイラー路の構築 …","t":"FFF","n":["eulerian_trail_from_edge_list","eulerian_trail_from_matrix","eulerian_trail_from_vertex_list"],"q":[[0,"eulerian_trail"]],"d":["…","…","…"],"i":[0,0,0],"f":[[[1,[2,[2]],3]],[[1,[2,[[2,[1]]]],3],[[2,[1]]]],[[1,[2,[[2,[1]]]],3],[[2,[1]]]]],"c":[],"p":[[15,"usize"],[3,"Vec"],[15,"bool"]]},\
"fenwick_tree":{"doc":"","t":"DLLLLLLLLLLLLLLLLLL","n":["FenwickTree","add","borrow","borrow_mut","clone","clone_into","eq","fmt","from","get","into","lower_bound","new","set","sum","to_owned","try_from","try_into","type_id"],"q":[[0,"fenwick_tree"]],"d":["","","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","<code>a[0] + ... + a[x - 1] &lt; w</code> を満たす最大の <code>x</code> を返す","","","","","","",""],"i":[0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],"f":[0,[[[4,[[0,[1,2,3]]]],5,[0,[1,2,3]]]],[[]],[[]],[[[4,[[0,[1,1,2,3]]]]],[[4,[[0,[1,1,2,3]]]]]],[[]],[[[4,[[0,[6,1,2,3]]]],[4,[[0,[6,1,2,3]]]]],7],[[[4,[[0,[8,1,2,3]]]],9],10],[[]],[[[4,[[0,[1,2,3]]]],5],[[0,[1,2,3]]]],[[]],[[[4,[[0,[11,12]],[0,[1,2,3]]]],[0,[11,12]],[0,[1,2,3]]],5],[[5,[0,[1,2,3]]],[[4,[[0,[1,2,3]]]]]],[[[4,[[0,[1,2,3]]]],5,[0,[1,2,3]]]],[[[4,[[0,[1,2,3]]]],[13,[5]]],[[0,[1,2,3]]]],[[]],[[],14],[[],14],[[],15]],"c":[],"p":[[8,"Clone"],[8,"AddAssign"],[8,"Sub"],[3,"FenwickTree"],[15,"usize"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[8,"PartialOrd"],[8,"SubAssign"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"floor_ceil_sum":{"doc":"","t":"FF","n":["ceil_sum","floor_sum"],"q":[[0,"floor_ceil_sum"]],"d":["Calculates the sum of <code>ceil((a * i + b) / m)</code> for <code>0 &lt;= i &lt; n</code>.","Calculates the sum of <code>floor((a * i + b) / m)</code> for <code>0 &lt;= i &lt; n</code>…"],"i":[0,0],"f":[[[1,1,1,1],1],[[1,1,1,1],1]],"c":[],"p":[[15,"i64"]]},\
"fps_utils":{"doc":"","t":"DLLLLLLFLLMLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["Fps","add","add","add_assign","add_assign","borrow","borrow_mut","bostan_mori","clone","clone_into","data","differential","eq","exp","fmt","fmt","from","from","integral","into","inverse","is_empty","len","log","mul","mul","mul_assign","mul_assign","mul_assign","neg","new","sub","sub","sub_assign","sub_assign","to_owned","to_string","truncate","try_from","try_into","type_id"],"q":[[0,"fps_utils"]],"d":["","","","","","","","<code>[x^n] p(x)/q(x)</code> を <code>O(k log k log n)</code> 時間で求める …","","","","微分","","mod x^deg","","","Returns the argument unchanged.","","積分","Calls <code>U::from(self)</code>.","mod x^deg","","","mod x^deg","","","","","","","","","","","","","","mod x^nを取る","","",""],"i":[0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]]]],[[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[[2,[1]],[2,[1]],3],1],[[[2,[[0,[4,1]]]]],[[2,[[0,[4,1]]]]]],[[]],0,[[[2,[1]]],[[2,[1]]]],[[[2,[[0,[5,1]]]],[2,[[0,[5,1]]]]],6],[[[2,[1]],7],[[2,[1]]]],[[[2,[1]],8],9],[[[2,[[0,[10,1]]]],8],9],[[]],[[[11,[1]]],[[2,[1]]]],[[[2,[1]]],[[2,[1]]]],[[]],[[[2,[1]],7],[[2,[1]]]],[[[2,[1]]],6],[[[2,[1]]],7],[[[2,[1]],7],[[2,[1]]]],[[[2,[1]]]],[[[2,[1]]]],[[[2,[1]],1]],[[[2,[1]],[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]]]],[7,[[2,[1]]]],[[[2,[1]]]],[[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]],[2,[1]]]],[[]],[[],12],[[[2,[1]],7],[[2,[1]]]],[[],13],[[],13],[[],14]],"c":[],"p":[[8,"ConvHelper"],[3,"Fps"],[15,"u64"],[8,"Clone"],[8,"PartialEq"],[15,"bool"],[15,"usize"],[3,"Formatter"],[6,"Result"],[8,"Debug"],[3,"Vec"],[3,"String"],[4,"Result"],[3,"TypeId"]]},\
"geometry_basics":{"doc":"","t":"DLLLLLLLLLLLLLLLLLLLLLLLLLMM","n":["Point","add","borrow","borrow_mut","clone","clone_into","cmp","cross","dot","eq","fmt","fmt","from","from","hash","into","mul","new","partial_cmp","square_dist","sub","to_owned","to_string","try_from","try_into","type_id","x","y"],"q":[[0,"geometry_basics"]],"d":["二次元座標を表す構造体","","","","","","","外積 これが0以上なら、self -&gt; rhs …","内積","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","(0, 0)からのユークリッド距離の二乗 <code>x^2 + y^2</code>","","","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[1,1]],[[]],[[]],[1,1],[[]],[[1,1],2],[[1,1],3],[[1,1],3],[[1,1],4],[[1,5],6],[[1,5],6],[[],1],[[]],[[1,7]],[[]],[[1,3]],[[3,3],1],[[1,1],[[8,[2]]]],[1,3],[[1,1]],[[]],[[],9],[[],10],[[],10],[[],11],0,0],"c":[],"p":[[3,"Point"],[4,"Ordering"],[15,"i64"],[15,"bool"],[3,"Formatter"],[6,"Result"],[8,"Hasher"],[4,"Option"],[3,"String"],[4,"Result"],[3,"TypeId"]]},\
"hld":{"doc":"HCPCの資料 …","t":"NNDELLLLLLMLLLLMLLLLMLMLMLLLLLLL","n":["Ascending","Descending","HLD","Path","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","depth","fmt","fmt","from","from","hld_in","into","into","lca","new","parent","path","sorted_graph","subtree","subtree_size","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"hld"]],"d":["hldの上では右から左に進む","hldの上では左から右に進む","","半開区間","","","","","","","各頂点の深さ","","","Returns the argument unchanged.","Returns the argument unchanged.","heavy pathを並べた配列における各頂点のindex …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","各頂点の親(根にはusize::MAXを入れる)","uからvへのパスを列挙する(これらはheavy …","…","…","…","","","","","","",""],"i":[1,1,0,0,2,1,2,1,1,1,2,2,1,2,1,2,2,1,2,2,2,2,2,2,2,1,2,1,2,1,2,1],"f":[0,0,0,0,[[]],[[]],[[]],[[]],[1,1],[[]],0,[[2,3],4],[[1,3],4],[[]],[[]],0,[[]],[[]],[[2,5,5],5],[[[6,[[6,[5]]]],5],2],0,[[2,5,5,7],[[6,[1]]]],0,[[2,5,7]],0,[[]],[[],8],[[],8],[[],8],[[],8],[[],9],[[],9]],"c":[],"p":[[4,"Path"],[3,"HLD"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"internal_bits":{"doc":"","t":"F","n":["ceil_log2"],"q":[[0,"internal_bits"]],"d":["From …"],"i":[0],"f":[[1,1]],"c":[],"p":[[15,"u32"]]},\
"internal_modint":{"doc":"","t":"IILFKKLKKFK","n":["ModInt","RemEuclidU32","inv","inv_gcd","modulus","new","pow","raw","rem_euclid_u32","safe_mod","value"],"q":[[0,"internal_modint"]],"d":["","Trait for primitive integer types.","","g = gcd(a,b)と、ax = g (mod b)なるgと0 &lt;= x &lt; …","","","","","","",""],"i":[0,0,5,0,5,5,5,5,3,0,5],"f":[0,0,[[]],[[1,1]],[[],2],[3],[4],[2],[2,2],[[1,1],1],[[],2]],"c":[],"p":[[15,"i64"],[15,"u32"],[8,"RemEuclidU32"],[15,"u64"],[8,"ModInt"]]},\
"internal_type_traits":{"doc":"","t":"IIIIIKKKK","n":["BoundedAbove","BoundedBelow","Integral","One","Zero","max_value","min_value","one","zero"],"q":[[0,"internal_type_traits"]],"d":["","","整数型を使いたいときのトレイト …","Class that has multiplicative identity element","Class that has additive identity element","","","The multiplicative identity element","The additive identity element"],"i":[0,0,0,0,0,1,2,3,4],"f":[0,0,0,0,0,[[]],[[]],[[]],[[]]],"c":[],"p":[[8,"BoundedAbove"],[8,"BoundedBelow"],[8,"One"],[8,"Zero"]]},\
"lazy_segtree":{"doc":"…","t":"DLLLLLLLLLLLLLLLLLLL","n":["LazySegTree","all_prod","apply","apply_range","apply_range_commutative","borrow","borrow_mut","fmt","from","from","get","into","max_right","min_left","new","prod","set","try_from","try_into","type_id"],"q":[[0,"lazy_segtree"]],"d":["","","","作用の可換性を仮定しない上での区間適用 …","可換な作用の区間適用","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]]]],[[[2,[1]],3]],[[[2,[1]],[4,[3]]]],[[[2,[1]],[4,[3]]]],[[]],[[]],[[[2,[[0,[5,1]]]],6],7],[[]],[8,[[2,[1]]]],[[[2,[1]],3]],[[]],[[[2,[1]],3,9],3],[[[2,[1]],3,9],3],[3,[[2,[1]]]],[[[2,[1]],[4,[3]]]],[[[2,[1]],3]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"ActionMonoid"],[3,"LazySegTree"],[15,"usize"],[8,"RangeBounds"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[8,"Fn"],[4,"Result"],[3,"TypeId"]]},\
"lazy_segtree_beats":{"doc":"…","t":"QIDKLKLLLLLKLLLKLLL","n":["Action","BeatsNode","LazySegtreeBeats","apply","apply_range","binary_operation","borrow","borrow_mut","fmt","from","from","id_node","into","new","prod","push","try_from","try_into","type_id"],"q":[[0,"lazy_segtree_beats"]],"d":["","Segment Tree Beats における内部のノード …","","作用の適用 成功したら<code>true</code>、失敗したら<code>false</code>…","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","…","","",""],"i":[2,0,0,2,3,2,3,3,3,3,3,2,3,3,3,2,3,3,3],"f":[0,0,0,[[],1],[[[3,[2]],[5,[4]]]],[[]],[[]],[[]],[[[3,[[0,[6,2]]]],7],8],[[]],[[[9,[2]]],[[3,[2]]]],[[]],[[]],[4,[[3,[2]]]],[[[3,[2]],[5,[4]]],2],[[]],[[],10],[[],10],[[],11]],"c":[],"p":[[15,"bool"],[8,"BeatsNode"],[3,"LazySegtreeBeats"],[15,"usize"],[8,"RangeBounds"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"lazy_segtree_utils":{"doc":"使用頻度の高い遅延セグ木達","t":"GGGIGGGKLLAKLLDDDDDDDDDDDDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["AddMaxLazySegTree","AddMinLazySegTree","AddSumLazySegTree","SumWrapper","UpdateMaxLazySegTree","UpdateMinLazySegTree","UpdateSumLazySegTree","from_vec","from_vec","from_vec","inner_types","prod_sum","prod_sum","prod_sum","AddAction","AddActionSum","AddMax","AddMin","AddSum","MaxMonoid","MinMonoid","SumMonoid","UpdateAction","UpdateActionSum","UpdateMax","UpdateMin","UpdateSum","apply","apply","apply","apply","binary_operation","binary_operation","binary_operation","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","composition","composition","composition","composition","eq","eq","eq","eq","eq","eq","eq","eq","eq","eq","eq","eq","eq","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","id_action","id_action","id_action","id_action","id_element","id_element","id_element","into","into","into","into","into","into","into","into","into","into","into","into","into","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id"],"q":[[0,"lazy_segtree_utils"],[14,"lazy_segtree_utils::inner_types"]],"d":["","","","…","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","Returns the argument unchanged.","","Returns the argument unchanged.","","","Returns the argument unchanged.","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,0,29,3,4,0,29,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,7,8,9,10,12,13,14,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20,7,8,9,10,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,7,7,8,8,8,9,9,9,10,10,10,15,16,17,18,19,20,7,8,9,10,12,13,14,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20,12,13,14,7,8,9,10,15,16,17,18,19,20],"f":[0,0,0,0,0,0,0,[1],[[[1,[2]]],[[3,[2]]]],[[[1,[2]]],[[4,[2]]]],0,[[[6,[5]]]],[[[3,[2]],[6,[5]]],2],[[[4,[2]],[6,[5]]],2],0,0,0,0,0,0,0,0,0,0,0,0,0,[[[7,[2]]]],[[[8,[2]]]],[[[9,[2]]]],[[[10,[2]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[12,[[0,[11,2]]]]],[[12,[[0,[11,2]]]]]],[[[13,[[0,[11,2]]]]],[[13,[[0,[11,2]]]]]],[[[14,[[0,[11,2]]]]],[[14,[[0,[11,2]]]]]],[[[7,[[0,[11,2]]]]],[[7,[[0,[11,2]]]]]],[[[8,[[0,[11,2]]]]],[[8,[[0,[11,2]]]]]],[[[9,[[0,[11,2]]]]],[[9,[[0,[11,2]]]]]],[[[10,[[0,[11,2]]]]],[[10,[[0,[11,2]]]]]],[[[15,[[0,[11,2]]]]],[[15,[[0,[11,2]]]]]],[[[16,[[0,[11,2]]]]],[[16,[[0,[11,2]]]]]],[[[17,[[0,[11,2]]]]],[[17,[[0,[11,2]]]]]],[[[18,[[0,[11,2]]]]],[[18,[[0,[11,2]]]]]],[[[19,[[0,[11,2]]]]],[[19,[[0,[11,2]]]]]],[[[20,[[0,[11,2]]]]],[[20,[[0,[11,2]]]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[7,[2]],[7,[2]]]],[[[8,[2]],[8,[2]]]],[[[9,[2]],[9,[2]]]],[[[10,[2]],[10,[2]]]],[[[12,[[0,[21,2]]]],[12,[[0,[21,2]]]]],22],[[[13,[[0,[21,2]]]],[13,[[0,[21,2]]]]],22],[[[14,[[0,[21,2]]]],[14,[[0,[21,2]]]]],22],[[[7,[[0,[21,2]]]],[7,[[0,[21,2]]]]],22],[[[8,[[0,[21,2]]]],[8,[[0,[21,2]]]]],22],[[[9,[[0,[21,2]]]],[9,[[0,[21,2]]]]],22],[[[10,[[0,[21,2]]]],[10,[[0,[21,2]]]]],22],[[[15,[[0,[21,2]]]],[15,[[0,[21,2]]]]],22],[[[16,[[0,[21,2]]]],[16,[[0,[21,2]]]]],22],[[[17,[[0,[21,2]]]],[17,[[0,[21,2]]]]],22],[[[18,[[0,[21,2]]]],[18,[[0,[21,2]]]]],22],[[[19,[[0,[21,2]]]],[19,[[0,[21,2]]]]],22],[[[20,[[0,[21,2]]]],[20,[[0,[21,2]]]]],22],[[[12,[[0,[23,2]]]],24],25],[[[13,[[0,[23,2]]]],24],25],[[[14,[[0,[23,2]]]],24],25],[[[7,[[0,[23,2]]]],24],25],[[[8,[[0,[23,2]]]],24],25],[[[9,[[0,[23,2]]]],24],25],[[[10,[[0,[23,2]]]],24],25],[[[15,[[0,[23,2]]]],24],25],[[[16,[[0,[23,2]]]],24],25],[[[17,[[0,[23,2]]]],24],25],[[[18,[[0,[23,2]]]],24],25],[[[19,[[0,[23,2]]]],24],25],[[[20,[[0,[23,2]]]],24],25],[[]],[[]],[[]],[[]],[26],[2,[[7,[2]]]],[2,[[8,[2]]]],[26],[[]],[2,[[9,[2]]]],[[]],[26],[26],[[]],[2,[[10,[2]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[],[[7,[2]]]],[[],[[8,[2]]]],[[],[[9,[2]]]],[[],[[10,[2]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],27],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28],[[],28]],"c":[],"p":[[3,"Vec"],[8,"Integral"],[6,"AddSumLazySegTree"],[6,"UpdateSumLazySegTree"],[15,"usize"],[8,"RangeBounds"],[3,"AddAction"],[3,"AddActionSum"],[3,"UpdateAction"],[3,"UpdateActionSum"],[8,"Clone"],[3,"MaxMonoid"],[3,"MinMonoid"],[3,"SumMonoid"],[3,"AddMax"],[3,"AddMin"],[3,"AddSum"],[3,"UpdateMax"],[3,"UpdateMin"],[3,"UpdateSum"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[15,"never"],[4,"Result"],[3,"TypeId"],[8,"SumWrapper"]]},\
"localize_closure":{"doc":"From …","t":"O","n":["mlambda"],"q":[[0,"localize_closure"]],"d":["Macro that define closure like macro. Unlike closure, this …"],"i":[0],"f":[0],"c":[],"p":[]},\
"lowlink":{"doc":"","t":"DMLLMLLLLMLMLLLL","n":["LowLink","articulation_points","borrow","borrow_mut","bridges","fmt","from","into","is_bridge","low","new","ord","try_from","try_into","two_edge_cc","type_id"],"q":[[0,"lowlink"]],"d":["無向グラフに対するLowLink","関節点 ソートはされていない","","","橋 ソートはされていない","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","頂点uとvを結ぶ辺が橋かどうかを返す <code>O(1)</code> …","","…","pre-order","","","2重辺連結成分分解 <code>O(V + E)</code> …",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,0,[[]],[[]],0,[[1,2],3],[[]],[[]],[[1,4,4],5],0,[[[6,[[6,[4]]]]],1],0,[[],7],[[],7],[1],[[],8]],"c":[],"p":[[3,"LowLink"],[3,"Formatter"],[6,"Result"],[15,"usize"],[15,"bool"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"matrix":{"doc":"行列ライブラリ 行列積は普通に<code>O(d^3)</code>…","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["Matrix","UsualSemiring","add","add_assign","add_assign","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","eq","eq","fmt","fmt","from","from","from","from","get","get_mut","into","into","mul","mul","mul_assign","new","one","pow","sub","sub_assign","to_owned","to_owned","transpose","try_from","try_from","try_into","try_into","type_id","type_id","unit","zero"],"q":[[0,"matrix"]],"d":["","通常の足し算、掛け算による半環","","","","","","","","","","","","","","","","Returns the argument unchanged.","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","",""],"i":[0,0,2,10,2,10,2,10,2,10,2,10,2,10,2,10,2,10,2,2,2,2,2,10,2,10,2,2,2,10,2,2,2,10,2,2,10,2,10,2,10,2,2,10],"f":[0,0,[[[2,[1]],[2,[1]]],[[2,[1]]]],[[]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[]],[[]],[[[10,[[0,[3,4,3,5,6,7,8,9]]]]],[[10,[[0,[3,4,3,5,6,7,8,9]]]]]],[[[2,[[0,[3,1]]]]],[[2,[[0,[3,1]]]]]],[[]],[[]],[[[10,[[0,[11,4,3,5,6,7,8,9]]]],[10,[[0,[11,4,3,5,6,7,8,9]]]]],12],[[[2,[[0,[11,1]]]],[2,[[0,[11,1]]]]],12],[[[10,[[0,[4,4,3,5,6,7,8,9]]]],13],14],[[[2,[[0,[4,1]]]],13],14],[[]],[[[15,[15]]],[[2,[1]]]],[[]],[[],[[2,[1]]]],[[[2,[1]],16,16]],[[[2,[1]],16,16]],[[]],[[]],[[]],[[[2,[1]],[2,[1]]],[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[16,16],[[2,[1]]]],[[]],[[[2,[1]],17],[[2,[1]]]],[[[2,[1]],[2,[1]]],[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[[2,[1]]],[[2,[1]]]],[[],18],[[],18],[[],18],[[],18],[[],19],[[],19],[16,[[2,[1]]]],[[]]],"c":[],"p":[[8,"Semiring"],[3,"Matrix"],[8,"Clone"],[8,"Debug"],[8,"Eq"],[8,"Zero"],[8,"One"],[8,"AddAssign"],[8,"Mul"],[3,"UsualSemiring"],[8,"PartialEq"],[15,"bool"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[15,"u64"],[4,"Result"],[3,"TypeId"]]},\
"maxflow":{"doc":"From …","t":"DDLLLLLMLLLLLLLLMLLLLLMLLLLLMLLLLLLL","n":["Edge","MaxFlow","add_edge","borrow","borrow","borrow_mut","borrow_mut","cap","change_edge","clone","clone_into","default","edges","eq","eq","flow","flow","flow_with_capacity","fmt","fmt","from","from","from","get_edge","into","into","min_cut","new","to","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"maxflow"]],"d":["","最大流を解く","","","","","","","","","","","","","","<code>s != t</code> must hold, otherwise it panics.","","Parameters","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","",""],"i":[0,0,2,6,2,6,2,6,2,2,2,2,2,6,2,2,6,2,6,2,6,2,6,2,6,2,2,2,6,2,6,2,6,2,6,2],"f":[0,0,[[[2,[1]],3,3,1],3],[[]],[[]],[[]],[[]],0,[[[2,[1]],3,1,1]],[[[2,[4]]],[[2,[4]]]],[[]],[[],[[2,[5]]]],[[[2,[1]]],[[7,[[6,[1]]]]]],[[[6,[[0,[8,1]]]],[6,[[0,[8,1]]]]],9],[[[2,[8]],[2,[8]]],9],[[[2,[1]],3,3],1],0,[[[2,[1]],3,3,1],1],[[[6,[[0,[10,1]]]],11],12],[[[2,[10]],11],12],[[]],[[]],0,[[[2,[1]],3],[[6,[1]]]],[[]],[[]],[[[2,[1]],3],[[7,[9]]]],[3,[[2,[1]]]],0,[[]],[[],13],[[],13],[[],13],[[],13],[[],14],[[],14]],"c":[],"p":[[8,"Integral"],[3,"MaxFlow"],[15,"usize"],[8,"Clone"],[8,"Default"],[3,"Edge"],[3,"Vec"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"TypeId"]]},\
"maxflow_lower_bound":{"doc":"最小流量制限付き最大流 …","t":"DLLLLLLLLLLLL","n":["MaxFlowLowerBound","add_edge","add_edge_with_lower_bound","borrow","borrow_mut","flow","from","get_edge","into","new","try_from","try_into","type_id"],"q":[[0,"maxflow_lower_bound"]],"d":["","…","…","","","…","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]],3,3,1],3],[[[2,[1]],3,3,[4,[1]]],3],[[]],[[]],[[[2,[1]],3,3],[[5,[1]]]],[[]],[[[2,[1]],3],[[6,[1]]]],[[]],[3,[[2,[1]]]],[[],7],[[],7],[[],8]],"c":[],"p":[[8,"Integral"],[3,"MaxFlowLowerBound"],[15,"usize"],[8,"RangeBounds"],[4,"Option"],[3,"Edge"],[4,"Result"],[3,"TypeId"]]},\
"mo":{"doc":"Mo’s algorithm 一般に二つのindex <code>(x, y)</code> …","t":"IDLLFLLLKLLLLLKKKK","n":["MoFuncs","MoRunner","borrow","borrow_mut","calc_mo_friendly_order","fmt","from","into","memo","new","run","try_from","try_into","type_id","x_minus","x_plus","y_minus","y_plus"],"q":[[0,"mo"]],"d":["…","","","","…","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","…","<code>querys</code> はオフラインで読み込んだクエリ(x, y) …","クエリ(0, …","","","","(x, y) -&gt; (x-1, y) の変更","(x, y) -&gt; (x+1, y) の変更","(x, y) -&gt; (x, y-1) の変更","(x, y) -&gt; (x, y+1) の変更"],"i":[0,0,3,3,0,3,3,3,6,3,3,3,3,3,6,6,6,6],"f":[0,0,[[]],[[]],[[1,1],[[2,[1]]]],[[3,4],5],[[]],[[]],[1],[[1,1],3],[[3,6]],[[],7],[[],7],[[],8],[1],[1],[1],[1]],"c":[],"p":[[15,"usize"],[3,"Vec"],[3,"MoRunner"],[3,"Formatter"],[6,"Result"],[8,"MoFuncs"],[4,"Result"],[3,"TypeId"]]},\
"modint_mersenne":{"doc":"","t":"DILLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLL","n":["ModIntMersenne","RemEuclidU64","add","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","borrow","borrow_mut","clone","clone_into","div","div_assign","div_assign","div_assign","div_assign","div_assign","div_assign","div_assign","div_assign","div_assign","div_assign","div_assign","eq","fmt","fmt","from","hash","into","inv","modulus","mul","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","neg","new","pow","rem_euclid_u64","sub","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","to_owned","to_string","try_from","try_into","type_id","value"],"q":[[0,"modint_mersenne"]],"d":["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,0,[1,1],[[1,2]],[[1,3]],[[1,4]],[[1,1]],[[1,5]],[[1,6]],[[1,7]],[[1,8]],[[1,9]],[[1,10]],[[1,11]],[[]],[[]],[1,1],[[]],[1,1],[[1,8]],[[1,6]],[[1,9]],[[1,5]],[[1,3]],[[1,11]],[[1,10]],[[1,2]],[[1,1]],[[1,4]],[[1,7]],[[1,1],12],[[1,13],14],[[1,13],14],[[]],[[1,15]],[[]],[1,1],[[],10],[1,1],[[1,2]],[[1,5]],[[1,10]],[[1,9]],[[1,8]],[[1,7]],[[1,4]],[[1,6]],[[1,3]],[[1,11]],[[1,1]],[1,1],[16,1],[[1,10],1],[[],1],[1,1],[[1,9]],[[1,1]],[[1,3]],[[1,10]],[[1,2]],[[1,8]],[[1,5]],[[1,4]],[[1,6]],[[1,7]],[[1,11]],[[]],[[],17],[[],18],[[],18],[[],19],[1,10]],"c":[],"p":[[3,"ModIntMersenne"],[15,"usize"],[15,"u32"],[15,"i16"],[15,"i64"],[15,"i32"],[15,"isize"],[15,"u8"],[15,"i8"],[15,"u64"],[15,"u16"],[15,"bool"],[3,"Formatter"],[6,"Result"],[8,"Hasher"],[8,"RemEuclidU64"],[3,"String"],[4,"Result"],[3,"TypeId"]]},\
"monoid_utils":{"doc":"よくつかうモノイド達","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["MaxMonoid","MinMonoid","binary_operation","binary_operation","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","eq","eq","fmt","fmt","from","from","id_element","id_element","into","into","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"monoid_utils"]],"d":["","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","",""],"i":[0,0,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4],"f":[0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[[3,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[[4,[[0,[1,2]]]]],[[4,[[0,[1,2]]]]]],[[]],[[]],[[[3,[[0,[5,2]]]],[3,[[0,[5,2]]]]],6],[[[4,[[0,[5,2]]]],[4,[[0,[5,2]]]]],6],[[[3,[[0,[7,2]]]],8],9],[[[4,[[0,[7,2]]]],8],9],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],10],[[],10],[[],10],[[],10],[[],11],[[],11]],"c":[],"p":[[8,"Clone"],[8,"Integral"],[3,"MaxMonoid"],[3,"MinMonoid"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"TypeId"]]},\
"multiset":{"doc":"…","t":"DLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["MultiSet","borrow","borrow_mut","buf","buf_mut","clone","clone_into","cmp","contains_key","count","default","eq","fmt","from","from","hash","insert_bunch","insert_one","into","is_empty","max_key","min_key","new","partial_cmp","remove_all","remove_bunch","remove_one","to_owned","try_from","try_into","type_id"],"q":[[0,"multiset"]],"d":["","","","","","","","","","","","","","Returns the argument unchanged.","","","keyをc個追加","keyを1個追加","Calls <code>U::from(self)</code>.","","","","","","keyをすべて削除する","keyをc個削除する","keyを一つ削除する","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[[[2,[1]]],[[4,[1,3]]]],[[[2,[1]]],[[4,[1,3]]]],[[[2,[[0,[5,1]]]]],[[2,[[0,[5,1]]]]]],[[]],[[[2,[[0,[1,1]]]],[2,[[0,[1,1]]]]],6],[[[2,[[8,[[0,[1,7]]]],1]],[0,[1,7]]],9],[[[2,[[8,[[0,[1,7]]]],1]],[0,[1,7]]],3],[[],[[2,[3]]]],[[[2,[[0,[10,1]]]],[2,[[0,[10,1]]]]],9],[[[2,[[0,[11,1]]]],12],13],[[]],[[[14,[1]]],[[2,[1]]]],[[[2,[[0,[15,1]]]],16]],[[[2,[1]],1,3]],[[[2,[1]],1]],[[]],[[[2,[1]]],9],[[[2,[1]]],[[17,[1]]]],[[[2,[1]]],[[17,[1]]]],[[],[[2,[1]]]],[[[2,[[0,[18,1]]]],[2,[[0,[18,1]]]]],[[17,[6]]]],[[[2,[[8,[[0,[1,7]]]],1]],[0,[1,7]]]],[[[2,[[8,[[0,[1,7]]]],1]],[0,[1,7]],3]],[[[2,[[8,[[0,[1,7]]]],1]],[0,[1,7]]]],[[]],[[],19],[[],19],[[],20]],"c":[],"p":[[8,"Ord"],[3,"MultiSet"],[15,"usize"],[3,"BTreeMap"],[8,"Clone"],[4,"Ordering"],[8,"Sized"],[8,"Borrow"],[15,"bool"],[8,"PartialEq"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[8,"Hash"],[8,"Hasher"],[4,"Option"],[8,"PartialOrd"],[4,"Result"],[3,"TypeId"]]},\
"next_permutation":{"doc":"","t":"DLLLLLLFFLLL","n":["Permutations","borrow","borrow_mut","from","into","into_iter","next","next_permutation","permutations","try_from","try_into","type_id"],"q":[[0,"next_permutation"]],"d":["","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","From …","…","","",""],"i":[0,3,3,3,3,3,3,0,0,3,3,3],"f":[0,[[]],[[]],[[]],[[]],[[]],[[[3,[[0,[1,2]]]]],4],[[],5],[[[6,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[],7],[[],7],[[],8]],"c":[],"p":[[8,"Ord"],[8,"Clone"],[3,"Permutations"],[4,"Option"],[15,"bool"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"ntt":{"doc":"FFT 原始根, NTT friendly MOD 高速化 Reference …","t":"IFKF","n":["ConvHelper","convolution","convolution","convolution_i64"],"q":[[0,"ntt"]],"d":["ModIntに畳み込みも追加したトレイト","…","","…"],"i":[0,0,1,0],"f":[0,[[],[[2,[1]]]],[[],2],[[],[[2,[3]]]]],"c":[],"p":[[8,"ConvHelper"],[3,"Vec"],[15,"i64"]]},\
"partially_persistent_unionfind":{"doc":"部分永続UnionFind …","t":"DLLLLLLLLLLLL","n":["PartiallyPersistentUnionFind","borrow","borrow_mut","from","into","leader","merge","new","same","size","try_from","try_into","type_id"],"q":[[0,"partially_persistent_unionfind"]],"d":["","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","時刻tにおいてxの属する集合の根を返す","xとyが属する集合を併合し、時間を進める …","","…","時刻tにおいてxの属する集合のサイズを返す","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[[]],[[]],[[1,2,2],2],[[1,2,2],2],[2,1],[[1,2,2,2],3],[[1,2,2],2],[[],4],[[],4],[[],5]],"c":[],"p":[[3,"PartiallyPersistentUnionFind"],[15,"usize"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"pcg32":{"doc":"From …","t":"DLLLLLLLLLLLLLL","n":["Pcg32","borrow","borrow_mut","clone","clone_into","fmt","from","init","init_rand","into","next_u32","to_owned","try_from","try_into","type_id"],"q":[[0,"pcg32"]],"d":["","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,2],3],[[]],[4,1],[[],1],[[]],[1,5],[[]],[[],6],[[],6],[[],7]],"c":[],"p":[[3,"Pcg32"],[3,"Formatter"],[6,"Result"],[15,"u64"],[15,"u32"],[4,"Result"],[3,"TypeId"]]},\
"potentialized_union_find":{"doc":"ポテンシャル付きUnion-Find 群を載せる  ","t":"DLLLLLLLLLLLLL","n":["PotentializedUnionFind","borrow","borrow_mut","diff","fmt","from","into","new","relate","root_and_diff","size","try_from","try_into","type_id"],"q":[[0,"potentialized_union_find"]],"d":["","","","xから見たyの差分が定義されていれば返す","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","xからみたyの差分を追加する …","代表元と、それから見た差分を求める","…","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[[[2,[1]],3,3],4],[[[2,[[0,[5,1]]]],6],7],[[]],[[]],[3,[[2,[1]]]],[[[2,[1]],3,3],[[9,[8]]]],[[[2,[1]],3]],[[[2,[1]],3],3],[[],9],[[],9],[[],10]],"c":[],"p":[[8,"Group"],[3,"PotentializedUnionFind"],[15,"usize"],[4,"Option"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"range_chmin_max_add_sum":{"doc":"Range chmin, chmax, add, update query Range min/max, sum …","t":"DLLLLLLLLLLLLLLLL","n":["RangeChminMaxAddSum","borrow","borrow_mut","fmt","from","from","into","prod_max","prod_min","prod_sum","range_add","range_chmax","range_chmin","range_update","try_from","try_into","type_id"],"q":[[0,"range_chmin_max_add_sum"]],"d":["","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","rangeの長さが0の場合は<code>i64::MIN</code>を返す","rangeの長さが0の場合は<code>i64::MAX</code>を返す","","","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[[1,2],3],[[]],[[[5,[4]]],1],[[]],[[1,[7,[6]]],4],[[1,[7,[6]]],4],[[1,[7,[6]]],4],[[1,[7,[6]],4]],[[1,[7,[6]],4]],[[1,[7,[6]],4]],[[1,[7,[6]],4]],[[],8],[[],8],[[],9]],"c":[],"p":[[3,"RangeChminMaxAddSum"],[3,"Formatter"],[6,"Result"],[15,"i64"],[3,"Vec"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"raq_rsq":{"doc":"蟻本p165をもとにしている fenwick tree …","t":"DLLLLLLLLLLL","n":["RAQRSQ","add","add_point","borrow","borrow_mut","from","into","new","sum","try_from","try_into","type_id"],"q":[[0,"raq_rsq"]],"d":["","区間加算","1点加算","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","",""],"i":[0,9,9,9,9,9,9,9,9,9,9,9],"f":[0,[[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]],[11,[10]],[0,[1,2,3,4,5,[7,[6]],8]]]],[[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]],10,[0,[1,2,3,4,5,[7,[6]],8]]]],[[]],[[]],[[]],[[]],[[10,[0,[1,2,3,4,5,[7,[6]],8]]],[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]]]],[[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]],[11,[10]]],[[0,[1,2,3,4,5,[7,[6]],8]]]],[[],12],[[],12],[[],13]],"c":[],"p":[[8,"Clone"],[8,"Add"],[8,"AddAssign"],[8,"Sub"],[8,"Neg"],[15,"u32"],[8,"From"],[8,"Mul"],[3,"RAQRSQ"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"rerooting":{"doc":"全方位木DP …","t":"DLLLLLLLLLL","n":["Rerooting","borrow","borrow_mut","fmt","from","get_ans","into","new","try_from","try_into","type_id"],"q":[[0,"rerooting"]],"d":["","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","モノイド<code>M</code>は<code>add_root</code>…","","",""],"i":[0,5,5,5,5,5,5,5,5,5,5],"f":[0,[[]],[[]],[[[5,[[0,[1,2,3]],[0,[1,4]]]],6],7],[[]],[[[5,[[0,[2,3]],4]],8]],[[]],[[[9,[[9,[8]]]],4],[[5,[[0,[2,3]],4]]]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Debug"],[8,"Monoid"],[8,"Commutative"],[8,"FnMut"],[3,"Rerooting"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"rolling_hash":{"doc":"","t":"DLLLLLLLLLLLLLLLLLLL","n":["RollingHash","borrow","borrow_mut","clone","clone_into","eq","fmt","from","get_base_pow","get_hash","get_prefix_hash","get_random_base","into","is_empty","len","new","to_owned","try_from","try_into","type_id"],"q":[[0,"rolling_hash"]],"d":["…","","","","","","","Returns the argument unchanged.","<code>base^i</code>を返す","部分列<code>s[range]</code>のhash値を返す <code>O(1)</code>","接頭辞のhash値を返す(<code>get_hash(0..i)</code>…","…","Calls <code>U::from(self)</code>.","","","sのrolling hashを構築 <code>O(|s|)</code> …","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,1],2],[[1,3],4],[[]],[[1,5],6],[[1,[7,[5]]],6],[[1,5],6],[[],8],[[]],[1,2],[1,5],[[[9,[8]]],1],[[]],[[],10],[[],10],[[],11]],"c":[],"p":[[3,"RollingHash"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"ModIntMersenne"],[8,"RangeBounds"],[15,"u64"],[4,"Option"],[4,"Result"],[3,"TypeId"]]},\
"scc":{"doc":"有効グラフの強連結成分分解を行います。 …","t":"DLLLLLLLLLLLLLLL","n":["SccGraph","add_edge","borrow","borrow_mut","clone","clone_into","fmt","from","from","into","new","scc","to_owned","try_from","try_into","type_id"],"q":[[0,"scc"]],"d":["","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[1,2,2]],[[]],[[]],[1,1],[[]],[[1,3],4],[[]],[[[5,[[5,[2]]]]],1],[[]],[2,1],[1,[[5,[[5,[2]]]]]],[[]],[[],6],[[],6],[[],7]],"c":[],"p":[[3,"SccGraph"],[15,"usize"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"segtree":{"doc":"From …","t":"DLLLLLLLLLLLLLLLLLLLL","n":["SegTree","all_prod","borrow","borrow_mut","clone","clone_into","eq","fmt","from","from","get","into","max_right","min_left","new","prod","set","to_owned","try_from","try_into","type_id"],"q":[[0,"segtree"]],"d":["","","","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]]]],[[]],[[]],[[[2,[[0,[3,1]]]]],[[2,[[0,[3,1]]]]]],[[]],[[[2,[[0,[4,1]]]],[2,[[0,[4,1]]]]],5],[[[2,[[0,[6,1]]]],7],8],[[]],[9,[[2,[1]]]],[[[2,[1]],10]],[[]],[[[2,[1]],10,11],10],[[[2,[1]],10,11],10],[10,[[2,[1]]]],[[[2,[1]],[12,[10]]]],[[[2,[1]],10]],[[]],[[],13],[[],13],[[],14]],"c":[],"p":[[8,"Monoid"],[3,"SegTree"],[8,"Clone"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"Fn"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"segtree_2d_compressed":{"doc":"…","t":"DLLLLLLLLLLLLL","n":["SegTree2DCompressed","add","borrow","borrow_mut","fmt","from","get","into","new","prod","set","try_from","try_into","type_id"],"q":[[0,"segtree_2d_compressed"]],"d":["Tは座標圧縮する型  ","…","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","…","","","","",""],"i":[0,4,4,4,4,4,4,4,4,4,4,4,4,4],"f":[0,[[[4,[[0,[1,2]],3]],3,3]],[[]],[[]],[[[4,[[0,[5,1,2]],[0,[5,3]]]],6],7],[[]],[[[4,[[0,[1,2]],3]],3,3]],[[]],[[],[[4,[[0,[1,2]],3]]]],[[[4,[[0,[1,2]],3]],[8,[3]],[8,[3]]]],[[[4,[[0,[1,2]],3]],3,3]],[[],9],[[],9],[[],10]],"c":[],"p":[[8,"Monoid"],[8,"Commutative"],[8,"Integral"],[3,"SegTree2DCompressed"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"segtree_2d_dense":{"doc":"内部で2次元配列を持つセグメント木 <code>O(HW)</code>…","t":"DLLLLLLLLLLLLLL","n":["SegTree2DDense","all_prod","borrow","borrow_mut","fmt","from","from","get","into","new","prod","set","try_from","try_into","type_id"],"q":[[0,"segtree_2d_dense"]],"d":["","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,3,3,3,3,3,3,3,3,3,3,3,3,3,3],"f":[0,[[[3,[[0,[1,2]]]]]],[[]],[[]],[[[3,[[0,[4,1,2]]]],5],6],[[]],[[[7,[7]]],[[3,[[0,[1,2]]]]]],[[[3,[[0,[1,2]]]],8,8]],[[]],[[8,8],[[3,[[0,[1,2]]]]]],[[[3,[[0,[1,2]]]],[9,[8]],[9,[8]]]],[[[3,[[0,[1,2]]]],8,8]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Monoid"],[8,"Commutative"],[3,"SegTree2DDense"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"sparse_table":{"doc":"…","t":"GGDLLLLLLLLLLLLL","n":["MaxSparseTable","MinSparseTable","SparseTable","borrow","borrow_mut","clone","clone_into","fmt","from","into","new","prod","to_owned","try_from","try_into","type_id"],"q":[[0,"sparse_table"]],"d":["","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<code>O(nlogn)</code>","<code>O(1)</code>","","","",""],"i":[0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3],"f":[0,0,0,[[]],[[]],[[[3,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[]],[[[3,[[0,[4,2]]]],5],6],[[]],[[]],[7,[[3,[2]]]],[[[3,[2]],[9,[8]]]],[[]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Clone"],[8,"IdempotentMonoid"],[3,"SparseTable"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"sparse_table_on_segtree":{"doc":"2D Sparse …","t":"DLLLLLLLLLL","n":["SparseTableOnSegTree","borrow","borrow_mut","fmt","from","into","new","prod","try_from","try_into","type_id"],"q":[[0,"sparse_table_on_segtree"]],"d":["","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<code>O(HWlogH)</code>","<code>O(logH)</code>","","",""],"i":[0,5,5,5,5,5,5,5,5,5,5],"f":[0,[[]],[[]],[[[5,[[0,[1,2,3,4]]]],6],7],[[]],[[]],[[[8,[8]]],[[5,[[0,[2,3,4]]]]]],[[[5,[[0,[2,3,4]]]],[10,[9]],[0,[[10,[9]],4]]]],[[],11],[[],11],[[],12]],"c":[],"p":[[8,"Debug"],[8,"IdempotentMonoid"],[8,"Commutative"],[8,"Clone"],[3,"SparseTableOnSegTree"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"static_modint":{"doc":"","t":"GGDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["ModInt1000000007","ModInt998244353","StaticModInt","add","add_assign","add_assign","borrow","borrow_mut","clone","clone_into","default","div","div_assign","div_assign","eq","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","from_str","hash","into","inv","modulus","modulus","mul","mul_assign","mul_assign","neg","new","new","one","pow","product","raw","raw","sub","sub_assign","sub_assign","sum","to_owned","to_string","try_from","try_into","type_id","value","value","zero"],"q":[[0,"static_modint"]],"d":["","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","","","","","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,0,0,[1,1],[[1,1]],[[1,2]],[[]],[[]],[1,1],[[]],[[],1],[1,1],[[1,1]],[[1,2]],[[1,1],3],[[1,4],5],[[1,4],5],[6,1],[7,1],[8,1],[9,1],[10,1],[11,1],[12,1],[13,1],[14,1],[15,1],[[]],[16,1],[17,1],[18,[[19,[1]]]],[[1,20]],[[]],[1,1],[[],14],[[],14],[1,1],[[1,1]],[[1,2]],[1,1],[2,1],[2,1],[[],1],[[1,16],1],[21,1],[14,1],[14,1],[1,1],[[1,2]],[[1,1]],[21,1],[[]],[[],22],[[],19],[[],19],[[],23],[1,14],[1,14],[[],1]],"c":[],"p":[[3,"StaticModInt"],[8,"RemEuclidU32"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"i64"],[15,"u8"],[15,"isize"],[15,"i128"],[15,"u128"],[15,"i32"],[15,"usize"],[15,"i8"],[15,"u32"],[15,"i16"],[15,"u64"],[15,"u16"],[15,"str"],[4,"Result"],[8,"Hasher"],[8,"Iterator"],[3,"String"],[3,"TypeId"]]},\
"top2":{"doc":"abc345e …","t":"DLLLLLLLLLLLLLLLL","n":["Top2Map","borrow","borrow_mut","clone","clone_into","default","first","fmt","from","insert","into","new","second","to_owned","try_from","try_into","type_id"],"q":[[0,"top2"]],"d":["Top2(大きい順)までのMapを持つ …","","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"f":[0,[[]],[[]],[[[5,[[0,[1,2,3]],[0,[1,4,3]]]]],[[5,[[0,[1,2,3]],[0,[1,4,3]]]]]],[[]],[[],[[5,[[0,[2,3]],[0,[4,3]]]]]],[[[5,[[0,[2,3]],[0,[4,3]]]]],6],[[[5,[[0,[7,2,3]],[0,[7,4,3]]]],8],9],[[]],[[[5,[[0,[2,3]],[0,[4,3]]]],[0,[2,3]],[0,[4,3]]]],[[]],[[],[[5,[[0,[2,3]],[0,[4,3]]]]]],[[[5,[[0,[2,3]],[0,[4,3]]]]],6],[[]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Clone"],[8,"Eq"],[8,"Copy"],[8,"Ord"],[3,"Top2Map"],[4,"Option"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"TypeId"]]},\
"unionfind":{"doc":"…","t":"DLLLLLLLLLLLLLLLLLLLL","n":["UnionFind","borrow","borrow_mut","clone","clone_into","eq","fmt","from","groups","into","is_empty","leader","len","merge","new","same","size","to_owned","try_from","try_into","type_id"],"q":[[0,"unionfind"]],"d":["","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","合併しつつ、合併した集合の代表元を返す","","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,1],2],[[1,3],4],[[]],[1,[[6,[[6,[5]]]]]],[[]],[1,2],[[1,5],5],[1,5],[[1,5,5],5],[5,1],[[1,5,5],2],[[1,5],5],[[]],[[],7],[[],7],[[],8]],"c":[],"p":[[3,"UnionFind"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"wavelet_matrix":{"doc":"Wavelet Matrix","t":"DLLLLLLLLLLLLLLLLLLLL","n":["WaveletMatrix","access","borrow","borrow_mut","clone","clone_into","fmt","from","into","new","next_value","prev_value","quantile","range_freq","rank","rank_less_eq_more","select","to_owned","try_from","try_into","type_id"],"q":[[0,"wavelet_matrix"]],"d":["0以上の静的な数列を扱う …","数列のpos番目の要素を復元する O(logσ)","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","…","…","…","…","…","数列の[0, …","…","数列のpos番目の数値numの位置を求める …","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[1,2],2],[[]],[[]],[1,1],[[]],[[1,3],4],[[]],[[]],[[],1],[[1,[0,[[5,[2]],6]],2],[[7,[2]]]],[[1,[0,[[5,[2]],6]],2],[[7,[2]]]],[[1,[5,[2]],2],2],[[1,[0,[[5,[2]],6]],[5,[2]]],2],[[1,2,2],2],[[1,2,[5,[2]]]],[[1,2,2],[[7,[2]]]],[[]],[[],8],[[],8],[[],9]],"c":[],"p":[[3,"WaveletMatrix"],[15,"usize"],[3,"Formatter"],[6,"Result"],[8,"RangeBounds"],[8,"Clone"],[4,"Option"],[4,"Result"],[3,"TypeId"]]},\
"wavelet_matrix_cum_sum":{"doc":"Wavelet Matrix …","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLL","n":["WMCumSumWrapper","WaveletMatrixCumSum","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","fmt","from","from","get","get_weight","into","into","new","new","prefix_rect_sum","rect_sum","rect_sum","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"wavelet_matrix_cum_sum"]],"d":["座標圧縮とx座標の重複除去を行うWrapper <code>T</code>…","Tは重さの型 Wavelet Matrix …","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","点(x, y)の重みを取得する","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","init_weightsは点の座標と重みのリスト <code>(x, y, w)</code>","<code>compressed_list[x] = y</code> が点(x, y)に、<code>weight_list[x] = w</code>…","…","矩形区間和内の点の重みの和を求める","矩形区間和内の点の重みの和を求める","","","","","","",""],"i":[0,0,7,3,7,3,3,3,3,7,3,7,3,7,3,7,3,3,7,3,3,7,3,7,3,7,3],"f":[0,0,[[]],[[]],[[]],[[]],[[[3,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[]],[[[3,[[0,[4,2]]]],5],6],[[]],[[]],[[[7,[2,2]],2,2],2],[[[3,[2]],8],2],[[]],[[]],[9,[[7,[2,2]]]],[[],[[3,[2]]]],[[[3,[2]],[10,[8]],8],2],[[[7,[2,2]],[10,[2]],[10,[2]]],2],[[[3,[2]],[0,[[10,[8]],1]],[10,[8]]],2],[[]],[[],11],[[],11],[[],11],[[],11],[[],12],[[],12]],"c":[],"p":[[8,"Clone"],[8,"Integral"],[3,"WaveletMatrixCumSum"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"WMCumSumWrapper"],[15,"usize"],[3,"Vec"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"wavelet_matrix_fenwick":{"doc":"Wavelet Matrix に Fenwick Tree (Binary Indexed Tree) …","t":"DLLLLLLLLLLLLL","n":["WMFenwickWrapper","add","borrow","borrow_mut","from","from_weight","get","into","new","rect_sum","set","try_from","try_into","type_id"],"q":[[0,"wavelet_matrix_fenwick"]],"d":["座標圧縮とx座標の重複除去を行うWrapper <code>T</code>…","点(x, y)の重みにadd_valを加算する","","","Returns the argument unchanged.","…","点(x, y)の重みを取得する","Calls <code>U::from(self)</code>.","すべて単位元で初期化する場合","矩形区間内の点の重みの和を求める","点(x, y)の重みをnew_valに更新する","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1,1]],1,1,1]],[[]],[[]],[[]],[3,[[2,[1,1]]]],[[[2,[1,1]],1,1],1],[[]],[3,[[2,[1,1]]]],[[[2,[1,1]],[4,[1]],[4,[1]]],1],[[[2,[1,1]],1,1,1]],[[],5],[[],5],[[],6]],"c":[],"p":[[8,"Integral"],[3,"WMFenwickWrapper"],[3,"Vec"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"wavelet_matrix_segtree":{"doc":"Wavelet Matrix に、ビットごとのSegment …","t":"DLLLLLLLLLLLLL","n":["WMSegWrapper","borrow","borrow_mut","from","from_weight","get","into","new","rect_sum_group","rect_sum_monoid","set","try_from","try_into","type_id"],"q":[[0,"wavelet_matrix_segtree"]],"d":["座標圧縮とx座標の重複除去を行うWrapper …","","","Returns the argument unchanged.","…","点(x, y)の重みを取得する","Calls <code>U::from(self)</code>.","すべて単位元で初期化する場合","群を重みとして載せている場合における、…","…","点(x, y)の重みをnew_valに更新する","","",""],"i":[0,5,5,5,5,5,5,5,5,5,5,5,5,5],"f":[0,[[]],[[]],[[]],[1,[[5,[[0,[2,3]],4]]]],[[[5,[[0,[2,3]],4]],4,4]],[[]],[1,[[5,[[0,[2,3]],4]]]],[[[5,[6,[0,[2,3]],4]],[7,[4]],[7,[4]]]],[[[5,[[0,[2,3]],4]],[7,[4]],[7,[4]]]],[[[5,[[0,[2,3]],4]],4,4]],[[],8],[[],8],[[],9]],"c":[],"p":[[3,"Vec"],[8,"Monoid"],[8,"Commutative"],[8,"Integral"],[3,"WMSegWrapper"],[8,"Group"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"zeta_bitset":{"doc":"…","t":"FFFF","n":["subset_mobius","subset_zeta","superset_mobius","superset_zeta"],"q":[[0,"zeta_bitset"]],"d":["…","bitの下位集合に関する高速ゼータ変換 …","…","bitの上位集合に関する高速ゼータ変換 …"],"i":[0,0,0,0],"f":[[[[3,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[[3,[2]],4],[[3,[2]]]],[[[3,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[[3,[2]],4],[[3,[2]]]]],"c":[],"p":[[8,"Sub"],[8,"Copy"],[3,"Vec"],[8,"Fn"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
