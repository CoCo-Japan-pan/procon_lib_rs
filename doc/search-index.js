var searchIndex = JSON.parse('{\
"algebra":{"doc":"<code>Algrebra</code>…","t":"IQIIIIIQIIQQQKKLKLKLKLKLKKKK","n":["Action","Action","ActionMonoid","Commutative","Group","IdempotentMonoid","Monoid","Monoid","NonCommutative","Semiring","Target","Target","Target","add_assign","apply","apply","binary_operation","binary_operation","composition","composition","id_action","id_action","id_element","id_element","inverse","mul","one","zero"],"q":[[0,"algebra"]],"d":["作用 作用自体もモノイドであることを要求 …","作用素のモノイド","自己準同型性を要求 …","可換  ","群 モノイドに加えて、逆元を持つ  ","冪等なモノイド つまり x = x op x …","モノイド","作用の対象のモノイド","非可換","半環 加算は可換モノイド 乗算はモノイド …","作用の対象","モノイドの要素","","","作用の適用","作用の適用","二項演算","二項演算","作用の合成(selfが先、rhsが後) (atcoder …","作用の合成(fが先、gが後)","恒等写像","恒等写像","単位元","単位元","","","",""],"i":[0,1,0,0,0,0,0,1,0,0,2,3,4,4,2,1,3,1,2,1,2,1,3,1,5,4,4,4],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]]],"c":[],"p":[[8,"ActionMonoid"],[8,"Action"],[8,"Monoid"],[8,"Semiring"],[8,"Group"]]},\
"auxiliary_tree":{"doc":"LCAベースの圧縮木 Auxiliary Tree","t":"DLLMLLLLLMLLL","n":["AuxiliaryTree","borrow","borrow_mut","euler_tour","fmt","from","gen_auxiliary_tree","into","new","pre_order_index","try_from","try_into","type_id"],"q":[[0,"auxiliary_tree"]],"d":["","","","","","Returns the argument unchanged.","LCAの関係を保ったまま圧縮された木を返す …","Calls <code>U::from(self)</code>.","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],0,[[1,2],3],[[]],[[1,[5,[4]]]],[[]],[4,1],0,[[],6],[[],6],[[],7]],"c":[],"p":[[3,"AuxiliaryTree"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"avl":{"doc":"AVL木 <code>std::collections::BTreeSet</code> …","t":"DLLLLLLLLLLLLLLLLLLLLLLLL","n":["AVL","borrow","borrow_mut","count","erase","erase_index","fmt","fmt","from","get","height","insert","insert_by_index","into","into_vec","is_empty","len","lower_bound","new","split_off","to_string","try_from","try_into","type_id","upper_bound"],"q":[[0,"avl"]],"d":["","","","","","","","","Returns the argument unchanged.","index番目(0-base)の値を取得","","","","Calls <code>U::from(self)</code>.","","","","","重複を許すならtrue","[0, index)を残し、[index, n)を返す","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[[[2,[1]],1],3],[[[2,[1]],1],4],[[2,3],5],[[[2,[6]],7],8],[[[2,[9]],7],8],[[]],[[2,3],5],[2,10],[[[2,[1]],1]],[[2,3]],[[]],[2,11],[2,4],[2,3],[[[2,[1]],1],3],[4,2],[[2,3],2],[[],12],[[],13],[[],13],[[],14],[[[2,[1]],1],3]],"c":[],"p":[[8,"PartialOrd"],[3,"AVL"],[15,"usize"],[15,"bool"],[4,"Option"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[8,"Display"],[15,"u8"],[3,"Vec"],[3,"String"],[4,"Result"],[3,"TypeId"]]},\
"binom":{"doc":"","t":"DLLLLLLLLLLL","n":["Binom","borrow","borrow_mut","cmp","from","get_fact","get_ifact","into","new","try_from","try_into","type_id"],"q":[[0,"binom"]],"d":["","","","nCkの計算(n&lt;kの場合は0とする)","Returns the argument unchanged.","n!","n!の逆元","Calls <code>U::from(self)</code>.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[[[2,[1]],3,3],1],[[]],[[[2,[1]],3],1],[[[2,[1]],3],1],[[]],[3,[[2,[1]]]],[[],4],[[],4],[[],5]],"c":[],"p":[[8,"ModInt"],[3,"Binom"],[15,"usize"],[4,"Result"],[3,"TypeId"]]},\
"bit_matrix":{"doc":"mod 2の世界での行列  ","t":"DLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["BitMatrix","borrow","borrow_mut","clone","clone_into","eq","fmt","from","from","from","from","from","gauss_jordan","get","index","into","linear_equation","new","or_and_mul","pow","set","to_owned","transpose","try_from","try_into","type_id","unit","xor_and_mul"],"q":[[0,"bit_matrix"]],"d":["","","","","","","","","","","Returns the argument unchanged.","","…","indexでアクセスしてもよい","","Calls <code>U::from(self)</code>.","連立一次方程式 Ax = …","","<code>+ = or, * = and</code> による行列積","行列のべき乗を計算する <code>mul_func</code>…","","","","","","","","<code>+ = xor, * = and</code> による行列積"],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,1],2],[[1,3],4],[[],1],[[],1],[[[5,[[5,[2]]]]],1],[[]],[[[5,[6]]],1],[[1,2]],[[1,7,7],2],[[1,7]],[[]],[1,8],[[7,7],1],[[1,1],1],[[1,9,10],1],[[1,7,7,2]],[[]],[1,1],[[],11],[[],11],[[],12],[7,1],[[1,1],1]],"c":[],"p":[[3,"BitMatrix"],[15,"bool"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[3,"BitSet"],[15,"usize"],[4,"Option"],[15,"u64"],[8,"Fn"],[4,"Result"],[3,"TypeId"]]},\
"bitset":{"doc":"…","t":"DLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["BitSet","all","any","bitand","bitand","bitand_assign","bitor","bitor","bitor_assign","bitxor","bitxor","bitxor_assign","borrow","borrow_mut","buffer","buffer_mut","chomp","clone","clone_into","count_ones","count_zeros","eq","flip","fmt","from","from","from","get","hash","index","into","new","none","not","not","set","shl","shl","shl_assign","shl_or","shr","shr","shr_assign","shr_or","size","to_owned","try_from","try_into","type_id"],"q":[[0,"bitset"]],"d":["","全て1かどうかを返す","どれか1つでも1があるかどうかを返す","","","","","","","","","","","","","","範囲外だが余分に持っているbitを0にする","","","1の数を返す","0の数を返す","","i番目のbitを反転させる","","Returns the argument unchanged.","","","indexでアクセスしてもよい","","","Calls <code>U::from(self)</code>.","size個のbitを持つBitSetを生成する(どれもunset)","全て0かどうかを返す","","","i番目のbitをbに設定する","","","","Faster left shift and or","","","","Faster right shift and or","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[1,2],[1,2],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[1,1]],[[]],[[]],[1],[1],[1],[1,1],[[]],[1,3],[1,3],[[1,1],2],[[1,4]],[[1,5],6],[[]],[[],1],[[[7,[2]]],1],[[1,4],2],[[1,8]],[[1,4],2],[[]],[4,1],[1,2],[1],[1,1],[[1,4,2]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[[1,4]],[1,4],[[]],[[],9],[[],9],[[],10]],"c":[],"p":[[3,"BitSet"],[15,"bool"],[15,"u32"],[15,"usize"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[8,"Hasher"],[4,"Result"],[3,"TypeId"]]},\
"capture":{"doc":"From …","t":"OO","n":["crecurse","memorize"],"q":[[0,"capture"]],"d":["Macro that returns a recursive function that …","Automatic memorization for recursive functions."],"i":[0,0],"f":[0,0],"c":[],"p":[]},\
"centroid_decomposition":{"doc":"木の(再帰的な)重心分解を行う","t":"DLLLLLLLLLLL","n":["CentroidDecomposition","borrow","borrow_mut","calc_centroid_tree","from","get_centroid","into","new","run","try_from","try_into","type_id"],"q":[[0,"centroid_decomposition"]],"d":["","","","centroid-tree グラフが空の場合は(vec![], …","Returns the argument unchanged.","…","Calls <code>U::from(self)</code>.","","<code>f = |used: &amp;[bool], centroid: usize| { ... }</code> <code>used</code>…","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1],[[]],[[1,2],2],[[]],[[[3,[[3,[2]]]]],1],[[1,4]],[[],5],[[],5],[[],6]],"c":[],"p":[[3,"CentroidDecomposition"],[15,"usize"],[3,"Vec"],[8,"FnMut"],[4,"Result"],[3,"TypeId"]]},\
"cht_offline":{"doc":"Li Chao treeによるCHT i64型で収まる前提 ax + b …","t":"DIEELLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLKLL","n":["CHTOffline","Compare","MaxCompare","MinCompare","add_line","add_line_segment","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","fmt","fmt","fmt","from","from","from","get","identity","identity","identity","into","into","into","new","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","update","update","update"],"q":[[0,"cht_offline"]],"d":["最大値クエリの場合は<code>T = MaxCompare</code>…","…","","","直線<code>ax + b</code>を追加する","線分 <code>ax + b (xはrangeの範囲内で有効)</code> …","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","xにおける最小値または最大値を求める","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","lhsをrhsで更新するべきならtrue","",""],"i":[0,0,0,0,2,2,5,8,2,5,8,2,5,8,2,5,8,2,2,1,5,8,5,8,2,2,5,8,2,5,8,2,5,8,2,1,5,8],"f":[0,0,0,0,[[[2,[1]],3,3]],[[[2,[1]],3,3,[4,[3]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[5,6],7],[[8,6],7],[[[2,[[0,[9,1]]]],6],7],[[]],[[]],[[]],[[[2,[1]],3],3],[[],3],[[],3],[[],3],[[]],[[]],[[]],[[[10,[3]]],[[2,[1]]]],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],12],[[],12],[[],12],[[3,3],13],[[3,3],13],[[3,3],13]],"c":[],"p":[[8,"Compare"],[3,"CHTOffline"],[15,"i64"],[8,"RangeBounds"],[4,"MaxCompare"],[3,"Formatter"],[6,"Result"],[4,"MinCompare"],[8,"Debug"],[3,"Vec"],[4,"Result"],[3,"TypeId"],[15,"bool"]]},\
"dual_segtree":{"doc":"作用素を通常のセグメント木のように持つ …","t":"DLLLLLLLLLLLLL","n":["DualSegTree","apply_commutative","apply_non_commutative","borrow","borrow_mut","fmt","from","get_composition","get_mapped","into","new","try_from","try_into","type_id"],"q":[[0,"dual_segtree"]],"d":["作用を区間適用, …","区間に可換な作用を適用する …","区間に非可換な作用を適用する …","","","","Returns the argument unchanged.","一点取得(その点への作用の合成を返す)","…","Calls <code>U::from(self)</code>.","","","",""],"i":[0,3,3,3,3,3,3,3,3,3,3,3,3,3],"f":[0,[[[3,[[0,[1,2]]]],[5,[4]],[0,[1,2]]]],[[[3,[[0,[1,6]]]],[5,[4]],[0,[1,6]]]],[[]],[[]],[[[3,[[0,[7,1]]]],8],9],[[]],[[[3,[1]],4],1],[[[3,[1]],4]],[[]],[4,[[3,[1]]]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Action"],[8,"Commutative"],[3,"DualSegTree"],[15,"usize"],[8,"RangeBounds"],[8,"NonCommutative"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"TypeId"]]},\
"dynamic_modint":{"doc":"動的に決定するModを持つModInt …","t":"DILLLLLLLLOLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["DynamicModInt","ModContainer","add","add_assign","add_assign","borrow","borrow_mut","clone","clone_into","default","define_modcontainer","div","div_assign","div_assign","eq","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","from_str","get_static_modulus","hash","into","inv","modulus","modulus","modulus","mul","mul_assign","mul_assign","neg","new","new","one","pow","product","raw","raw","set_modulus","set_modulus","sub","sub_assign","sub_assign","sum","to_owned","to_string","try_from","try_into","type_id","value","value","zero"],"q":[[0,"dynamic_modint"]],"d":["","","","","","","","","","","ModContainerを定義するマクロ …","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","","","","","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,0,[[[2,[1]]],[[2,[1]]]],[[[2,[1]],3]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[[2,[[0,[4,1]]]]],[[2,[[0,[4,1]]]]]],[[]],[[],[[2,[[0,[5,1]]]]]],0,[[[2,[1]]],[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]],3]],[[[2,[[0,[6,1]]]],[2,[[0,[6,1]]]]],7],[[[2,[1]],8],9],[[[2,[[0,[10,1]]]],8],9],[11,[[2,[1]]]],[12,[[2,[1]]]],[13,[[2,[1]]]],[14,[[2,[1]]]],[15,[[2,[1]]]],[16,[[2,[1]]]],[17,[[2,[1]]]],[18,[[2,[1]]]],[19,[[2,[1]]]],[20,[[2,[1]]]],[21,[[2,[1]]]],[[]],[22,[[2,[1]]]],[23,[[25,[[2,[1]],24]]]],[[],[[26,[11]]]],[[[2,[[0,[27,1]]]],28]],[[]],[[[2,[1]]],[[2,[1]]]],[[],11],[[],11],[[],11],[[[2,[1]]],[[2,[1]]]],[[[2,[1]],3]],[[[2,[1]],[2,[1]]]],[[[2,[1]]],[[2,[1]]]],[3,[[2,[1]]]],[3,[[2,[1]]]],[[],[[2,[1]]]],[[[2,[1]],12],[[2,[1]]]],[29,[[2,[1]]]],[11,[[2,[1]]]],[11,[[2,[1]]]],[11],[11],[[[2,[1]]],[[2,[1]]]],[[[2,[1]],3]],[[[2,[1]],[2,[1]]]],[29,[[2,[1]]]],[[]],[[],30],[[],25],[[],25],[[],31],[[[2,[1]]],11],[[[2,[1]]],11],[[],[[2,[1]]]]],"c":[],"p":[[8,"ModContainer"],[3,"DynamicModInt"],[8,"RemEuclidU32"],[8,"Clone"],[8,"Default"],[8,"PartialEq"],[15,"bool"],[3,"Formatter"],[6,"Result"],[8,"Debug"],[15,"u32"],[15,"u64"],[15,"i8"],[15,"i32"],[15,"u128"],[15,"isize"],[15,"i16"],[15,"u8"],[15,"i64"],[15,"i128"],[15,"usize"],[15,"u16"],[15,"str"],[3,"ParseIntError"],[4,"Result"],[3,"OnceLock"],[8,"Hash"],[8,"Hasher"],[8,"Iterator"],[3,"String"],[3,"TypeId"]]},\
"enumerate_inv_mods":{"doc":"","t":"F","n":["enumerate_invs"],"q":[[0,"enumerate_inv_mods"]],"d":["[1, n)のmod逆元列挙を<code>O(n)</code>で行う (index …"],"i":[0],"f":[[1,[[3,[2]]]]],"c":[],"p":[[15,"usize"],[8,"ModInt"],[3,"Vec"]]},\
"eratosthenes":{"doc":"エラトステネスの篩","t":"DLLLLLLLLLLLL","n":["Eratosthenes","borrow","borrow_mut","divisors","factorize","from","get_primes","into","is_prime","new","try_from","try_into","type_id"],"q":[[0,"eratosthenes"]],"d":["","","","約数の個数オーダーで約数列挙 …","<code>O(log N)</code> で素因数分解 (素因数、べき) …","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","<code>O(NloglogN)</code>","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[[1,2],[[3,[2]]]],[[1,2],3],[[]],[1],[[]],[[1,2],4],[2,1],[[],5],[[],5],[[],6]],"c":[],"p":[[3,"Eratosthenes"],[15,"usize"],[3,"Vec"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"euler_tour":{"doc":"頂点に着目したオイラーツアー …","t":"DLLMMMLLLMLLLLLL","n":["EulerTour","borrow","borrow_mut","depth","euler_tour_vertex","first_occurrence","fmt","from","into","last_occurrence","lca","lca_multiple","new","try_from","try_into","type_id"],"q":[[0,"euler_tour"]],"d":["","","","各頂点の深さ","頂点に着目したオイラーツアー","…","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","…","SparseTableを用いているので、<code>O(1)</code>","","SparseTableを構築しているので、<code>O(NlogN)</code>","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],0,0,0,[[1,2],3],[[]],[[]],0,[[1,4,4],4],[1,4],[4,1],[[],5],[[],5],[[],6]],"c":[],"p":[[3,"EulerTour"],[3,"Formatter"],[6,"Result"],[15,"usize"],[4,"Result"],[3,"TypeId"]]},\
"eulerian_trail":{"doc":"オイラー路の構築 …","t":"FFF","n":["eulerian_trail_from_edge_list","eulerian_trail_from_matrix","eulerian_trail_from_vertex_list"],"q":[[0,"eulerian_trail"]],"d":["…","…","…"],"i":[0,0,0],"f":[[[1,[2,[2]],3]],[[1,[2,[[2,[1]]]],3],[[2,[1]]]],[[1,[2,[[2,[1]]]],3],[[2,[1]]]]],"c":[],"p":[[15,"usize"],[3,"Vec"],[15,"bool"]]},\
"fenwick_tree":{"doc":"","t":"DLLLLLLLLLLLLLLLLL","n":["FenwickTree","add","borrow","borrow_mut","clone","clone_into","eq","fmt","from","into","lower_bound","new","set","sum","to_owned","try_from","try_into","type_id"],"q":[[0,"fenwick_tree"]],"d":["","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<code>a[0] + ... a[x] &gt;= w</code> となる最小の x を返す","","","","","","",""],"i":[0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],"f":[0,[[[4,[[0,[1,2,3]]]],5,[0,[1,2,3]]]],[[]],[[]],[[[4,[[0,[1,1,2,3]]]]],[[4,[[0,[1,1,2,3]]]]]],[[]],[[[4,[[0,[6,1,2,3]]]],[4,[[0,[6,1,2,3]]]]],7],[[[4,[[0,[8,1,2,3]]]],9],10],[[]],[[]],[[[4,[[0,[11,12]],[0,[1,2,3]]]],[0,[11,12]],[0,[1,2,3]]],5],[[5,[0,[1,2,3]]],[[4,[[0,[1,2,3]]]]]],[[[4,[[0,[1,2,3]]]],5,[0,[1,2,3]]]],[[[4,[[0,[1,2,3]]]],[13,[5]]],[[0,[1,2,3]]]],[[]],[[],14],[[],14],[[],15]],"c":[],"p":[[8,"Clone"],[8,"AddAssign"],[8,"Sub"],[3,"FenwickTree"],[15,"usize"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[8,"PartialOrd"],[8,"SubAssign"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"fps_utils":{"doc":"","t":"DLLLLLLLLMLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["Fps","add","add","add_assign","add_assign","borrow","borrow_mut","clone","clone_into","data","differential","eq","exp","fmt","fmt","from","from","integral","into","inverse","is_empty","len","log","mul","mul","mul_assign","mul_assign","mul_assign","neg","new","sub","sub","sub_assign","sub_assign","to_owned","to_string","truncate","try_from","try_into","type_id"],"q":[[0,"fps_utils"]],"d":["","","","","","","","","","","微分","","mod x^deg","","","Returns the argument unchanged.","","積分","Calls <code>U::from(self)</code>.","mod x^deg","","","mod x^deg","","","","","","","","","","","","","","mod x^nを取る","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]]]],[[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[[2,[[0,[3,1]]]]],[[2,[[0,[3,1]]]]]],[[]],0,[[[2,[1]]],[[2,[1]]]],[[[2,[[0,[4,1]]]],[2,[[0,[4,1]]]]],5],[[[2,[1]],6],[[2,[1]]]],[[[2,[1]],7],8],[[[2,[[0,[9,1]]]],7],8],[[]],[[[10,[1]]],[[2,[1]]]],[[[2,[1]]],[[2,[1]]]],[[]],[[[2,[1]],6],[[2,[1]]]],[[[2,[1]]],5],[[[2,[1]]],6],[[[2,[1]],6],[[2,[1]]]],[[[2,[1]]]],[[[2,[1]]]],[[[2,[1]],1]],[[[2,[1]],[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]]]],[6,[[2,[1]]]],[[[2,[1]]]],[[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[[2,[1]],[2,[1]]]],[[]],[[],11],[[[2,[1]],6],[[2,[1]]]],[[],12],[[],12],[[],13]],"c":[],"p":[[8,"ConvHelper"],[3,"Fps"],[8,"Clone"],[8,"PartialEq"],[15,"bool"],[15,"usize"],[3,"Formatter"],[6,"Result"],[8,"Debug"],[3,"Vec"],[3,"String"],[4,"Result"],[3,"TypeId"]]},\
"hld":{"doc":"HCPCの資料 …","t":"NNDELLLLLLMLLLLMLLLLMLMLMLLLLLLL","n":["Ascending","Descending","HLD","Path","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","depth","fmt","fmt","from","from","hld_in","into","into","lca","new","parent","path","sorted_graph","subtree","subtree_size","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"hld"]],"d":["hldの上では右から左に進む","hldの上では左から右に進む","","","","","","","","","各頂点の深さ","","","Returns the argument unchanged.","Returns the argument unchanged.","heavy pathを並べた配列における各頂点のindex …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","各頂点の親(根にはusize::MAXを入れる)","uからvへのパスを列挙する(これらはheavy …","…","…","…","","","","","","",""],"i":[1,1,0,0,2,1,2,1,1,1,2,2,1,2,1,2,2,1,2,2,2,2,2,2,2,1,2,1,2,1,2,1],"f":[0,0,0,0,[[]],[[]],[[]],[[]],[1,1],[[]],0,[[2,3],4],[[1,3],4],[[]],[[]],0,[[]],[[]],[[2,5,5],5],[[[6,[[6,[5]]]],5],2],0,[[2,5,5,7],[[6,[1]]]],0,[[2,5,7]],0,[[]],[[],8],[[],8],[[],8],[[],8],[[],9],[[],9]],"c":[],"p":[[4,"Path"],[3,"HLD"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"internal_bits":{"doc":"","t":"F","n":["ceil_log2"],"q":[[0,"internal_bits"]],"d":[""],"i":[0],"f":[[1,1]],"c":[],"p":[[15,"u32"]]},\
"internal_modint":{"doc":"","t":"IILFKKLKKFK","n":["ModInt","RemEuclidU32","inv","inv_gcd","modulus","new","pow","raw","rem_euclid_u32","safe_mod","value"],"q":[[0,"internal_modint"]],"d":["","Trait for primitive integer types.","","g = gcd(a,b)と、ax = g (mod b)なるgと0 &lt;= x &lt; …","","","","","","",""],"i":[0,0,5,0,5,5,5,5,3,0,5],"f":[0,0,[[]],[[1,1]],[[],2],[3],[4],[2],[2,2],[[1,1],1],[[],2]],"c":[],"p":[[15,"i64"],[15,"u32"],[8,"RemEuclidU32"],[15,"u64"],[8,"ModInt"]]},\
"internal_type_traits":{"doc":"","t":"IIIIIKKKK","n":["BoundedAbove","BoundedBelow","Integral","One","Zero","max_value","min_value","one","zero"],"q":[[0,"internal_type_traits"]],"d":["","","数値型を使いたいときのトレイト …","Class that has multiplicative identity element","Class that has additive identity element","","","The multiplicative identity element","The additive identity element"],"i":[0,0,0,0,0,1,2,3,4],"f":[0,0,0,0,0,[[]],[[]],[[]],[[]]],"c":[],"p":[[8,"BoundedAbove"],[8,"BoundedBelow"],[8,"One"],[8,"Zero"]]},\
"lazy_segtree":{"doc":"From …","t":"DLLLLLLLLLLLLLLLLLLL","n":["LazySegTree","all_prod","apply","apply_range_commutative","apply_range_non_commutative","borrow","borrow_mut","fmt","from","from","get","into","max_right","min_left","new","prod","set","try_from","try_into","type_id"],"q":[[0,"lazy_segtree"]],"d":["","","","可換な作用の区間適用","非可換な作用の区間適用","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]]]],[[[2,[1]],3]],[[[2,[1]],[4,[3]]]],[[[2,[1]],[4,[3]]]],[[]],[[]],[[[2,[[0,[5,1]]]],6],7],[[]],[8,[[2,[1]]]],[[[2,[1]],3]],[[]],[[[2,[1]],3,9],3],[[[2,[1]],3,9],3],[3,[[2,[1]]]],[[[2,[1]],[4,[3]]]],[[[2,[1]],3]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"ActionMonoid"],[3,"LazySegTree"],[15,"usize"],[8,"RangeBounds"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[8,"Fn"],[4,"Result"],[3,"TypeId"]]},\
"localize_closure":{"doc":"From …","t":"O","n":["mlambda"],"q":[[0,"localize_closure"]],"d":["Macro that define closure like macro. Unlike closure, this …"],"i":[0],"f":[0],"c":[],"p":[]},\
"matrix":{"doc":"行列ライブラリ 行列積は普通に<code>O(d^3)</code>…","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["Matrix","UsualSemiring","add","add_assign","add_assign","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","eq","eq","fmt","fmt","from","from","from","from","get","get_mut","into","into","mul","mul","mul_assign","new","one","pow","sub","sub_assign","to_owned","to_owned","transpose","try_from","try_from","try_into","try_into","type_id","type_id","unit","zero"],"q":[[0,"matrix"]],"d":["","通常の足し算、掛け算による半環","","","","","","","","","","","","","","","","Returns the argument unchanged.","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","",""],"i":[0,0,2,10,2,10,2,10,2,10,2,10,2,10,2,10,2,10,2,2,2,2,2,10,2,10,2,2,2,10,2,2,2,10,2,2,10,2,10,2,10,2,2,10],"f":[0,0,[[[2,[1]],[2,[1]]],[[2,[1]]]],[[]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[]],[[]],[[[10,[[0,[3,4,3,5,6,7,8,9]]]]],[[10,[[0,[3,4,3,5,6,7,8,9]]]]]],[[[2,[[0,[3,1]]]]],[[2,[[0,[3,1]]]]]],[[]],[[]],[[[10,[[0,[11,4,3,5,6,7,8,9]]]],[10,[[0,[11,4,3,5,6,7,8,9]]]]],12],[[[2,[[0,[11,1]]]],[2,[[0,[11,1]]]]],12],[[[10,[[0,[4,4,3,5,6,7,8,9]]]],13],14],[[[2,[[0,[4,1]]]],13],14],[[]],[[[15,[15]]],[[2,[1]]]],[[]],[[],[[2,[1]]]],[[[2,[1]],16,16]],[[[2,[1]],16,16]],[[]],[[]],[[]],[[[2,[1]],[2,[1]]],[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[16,16],[[2,[1]]]],[[]],[[[2,[1]],17],[[2,[1]]]],[[[2,[1]],[2,[1]]],[[2,[1]]]],[[[2,[1]],[2,[1]]]],[[]],[[]],[[[2,[1]]],[[2,[1]]]],[[],18],[[],18],[[],18],[[],18],[[],19],[[],19],[16,[[2,[1]]]],[[]]],"c":[],"p":[[8,"Semiring"],[3,"Matrix"],[8,"Clone"],[8,"Debug"],[8,"Eq"],[8,"Zero"],[8,"One"],[8,"AddAssign"],[8,"Mul"],[3,"UsualSemiring"],[8,"PartialEq"],[15,"bool"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[15,"u64"],[4,"Result"],[3,"TypeId"]]},\
"maxflow":{"doc":"From …","t":"DDLLLLLMLLLLLLLLMLLLLLMLLLLLMLLLLLLL","n":["Edge","MaxFlow","add_edge","borrow","borrow","borrow_mut","borrow_mut","cap","change_edge","clone","clone_into","default","edges","eq","eq","flow","flow","flow_with_capacity","fmt","fmt","from","from","from","get_edge","into","into","min_cut","new","to","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"maxflow"]],"d":["","最大流を解く","","","","","","","","","","","","","","<code>s != t</code> must hold, otherwise it panics.","","Parameters","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","",""],"i":[0,0,2,6,2,6,2,6,2,2,2,2,2,6,2,2,6,2,6,2,6,2,6,2,6,2,2,2,6,2,6,2,6,2,6,2],"f":[0,0,[[[2,[1]],3,3,1],3],[[]],[[]],[[]],[[]],0,[[[2,[1]],3,1,1]],[[[2,[4]]],[[2,[4]]]],[[]],[[],[[2,[5]]]],[[[2,[1]]],[[7,[[6,[1]]]]]],[[[6,[[0,[8,1]]]],[6,[[0,[8,1]]]]],9],[[[2,[8]],[2,[8]]],9],[[[2,[1]],3,3],1],0,[[[2,[1]],3,3,1],1],[[[6,[[0,[10,1]]]],11],12],[[[2,[10]],11],12],[[]],[[]],0,[[[2,[1]],3],[[6,[1]]]],[[]],[[]],[[[2,[1]],3],[[7,[9]]]],[3,[[2,[1]]]],0,[[]],[[],13],[[],13],[[],13],[[],13],[[],14],[[],14]],"c":[],"p":[[8,"Integral"],[3,"MaxFlow"],[15,"usize"],[8,"Clone"],[8,"Default"],[3,"Edge"],[3,"Vec"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"TypeId"]]},\
"maxflow_lower_bound":{"doc":"最小流量制限付き最大流 …","t":"DLLLLLLLLLLLL","n":["MaxFlowLowerBound","add_edge","add_edge_with_lower_bound","borrow","borrow_mut","flow","from","get_edge","into","new","try_from","try_into","type_id"],"q":[[0,"maxflow_lower_bound"]],"d":["","…","…","","","…","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]],3,3,1],3],[[[2,[1]],3,3,[4,[1]]],3],[[]],[[]],[[[2,[1]],3,3],[[5,[1]]]],[[]],[[[2,[1]],3],[[6,[1]]]],[[]],[3,[[2,[1]]]],[[],7],[[],7],[[],8]],"c":[],"p":[[8,"Integral"],[3,"MaxFlowLowerBound"],[15,"usize"],[8,"RangeBounds"],[4,"Option"],[3,"Edge"],[4,"Result"],[3,"TypeId"]]},\
"mo":{"doc":"区間[L, …","t":"IDKKLLLLLKLKKLLLL","n":["MoFuncs","MoRunner","add_left","add_right","borrow","borrow_mut","fmt","from","into","memo","new","remove_left","remove_right","run","try_from","try_into","type_id"],"q":[[0,"mo"]],"d":["","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","",""],"i":[0,0,6,6,2,2,2,2,2,6,2,6,6,2,2,2,2],"f":[0,0,[1],[1],[[]],[[]],[[2,3],4],[[]],[[]],[1],[[1,5],2],[1],[1],[[2,6]],[[],7],[[],7],[[],8]],"c":[],"p":[[15,"usize"],[3,"MoRunner"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[8,"MoFuncs"],[4,"Result"],[3,"TypeId"]]},\
"modint_mersenne":{"doc":"","t":"DILLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLL","n":["ModIntMersenne","RemEuclidU64","add","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","add_assign","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","hash","into","modulus","mul","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","mul_assign","neg","new","pow","rem_euclid_u64","sub","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","sub_assign","to_owned","to_string","try_from","try_into","type_id","value"],"q":[[0,"modint_mersenne"]],"d":["","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,0,[1,1],[[1,2]],[[1,3]],[[1,4]],[[1,5]],[[1,6]],[[1,7]],[[1,8]],[[1,9]],[[1,10]],[[1,1]],[[1,11]],[[]],[[]],[1,1],[[]],[[1,1],12],[[1,13],14],[[1,13],14],[[]],[[1,15]],[[]],[[],5],[1,1],[[1,8]],[[1,7]],[[1,6]],[[1,11]],[[1,3]],[[1,9]],[[1,1]],[[1,5]],[[1,10]],[[1,2]],[[1,4]],[1,1],[16,1],[[1,5],1],[[],1],[1,1],[[1,3]],[[1,7]],[[1,5]],[[1,10]],[[1,1]],[[1,6]],[[1,11]],[[1,9]],[[1,4]],[[1,8]],[[1,2]],[[]],[[],17],[[],18],[[],18],[[],19],[1,5]],"c":[],"p":[[3,"ModIntMersenne"],[15,"i32"],[15,"u8"],[15,"i8"],[15,"u64"],[15,"isize"],[15,"i16"],[15,"u32"],[15,"u16"],[15,"i64"],[15,"usize"],[15,"bool"],[3,"Formatter"],[6,"Result"],[8,"Hasher"],[8,"RemEuclidU64"],[3,"String"],[4,"Result"],[3,"TypeId"]]},\
"next_permutation":{"doc":"","t":"DLLLLLLFFLLL","n":["Permutations","borrow","borrow_mut","from","into","into_iter","next","next_permutation","permutations","try_from","try_into","type_id"],"q":[[0,"next_permutation"]],"d":["","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","From …","…","","",""],"i":[0,3,3,3,3,3,3,0,0,3,3,3],"f":[0,[[]],[[]],[[]],[[]],[[]],[[[3,[[0,[1,2]]]]],4],[[],5],[[[6,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[],7],[[],7],[[],8]],"c":[],"p":[[8,"Ord"],[8,"Clone"],[3,"Permutations"],[4,"Option"],[15,"bool"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"ntt":{"doc":"FFT 原始根, NTT friendly MOD 高速化 Reference …","t":"IFKF","n":["ConvHelper","convolution","convolution","convolution_i64"],"q":[[0,"ntt"]],"d":["ModIntに畳み込みも追加したトレイト","…","","…"],"i":[0,0,1,0],"f":[0,[[],[[2,[1]]]],[[],2],[[],[[2,[3]]]]],"c":[],"p":[[8,"ConvHelper"],[3,"Vec"],[15,"i64"]]},\
"pcg32":{"doc":"From …","t":"DLLLLLLLLLLLLLL","n":["Pcg32","borrow","borrow_mut","clone","clone_into","fmt","from","init","init_rand","into","next_u32","to_owned","try_from","try_into","type_id"],"q":[[0,"pcg32"]],"d":["","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,2],3],[[]],[4,1],[[],1],[[]],[1,5],[[]],[[],6],[[],6],[[],7]],"c":[],"p":[[3,"Pcg32"],[3,"Formatter"],[6,"Result"],[15,"u64"],[15,"u32"],[4,"Result"],[3,"TypeId"]]},\
"potentialized_union_find":{"doc":"ポテンシャル付きUnion-Find 群を載せる  ","t":"DLLLLLLLLLLLLL","n":["PotentializedUnionFind","borrow","borrow_mut","diff","fmt","from","into","new","relate","root_and_diff","size","try_from","try_into","type_id"],"q":[[0,"potentialized_union_find"]],"d":["","","","xから見たyの差分が定義されていれば返す","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","xからみたyの差分を追加する …","代表元と、それから見た差分を求める","…","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[[[2,[1]],3,3],4],[[[2,[[0,[5,1]]]],6],7],[[]],[[]],[3,[[2,[1]]]],[[[2,[1]],3,3],[[9,[8]]]],[[[2,[1]],3]],[[[2,[1]],3],3],[[],9],[[],9],[[],10]],"c":[],"p":[[8,"Group"],[3,"PotentializedUnionFind"],[15,"usize"],[4,"Option"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"raq_rsq":{"doc":"蟻本p165をもとにしている fenwick tree …","t":"DLLLLLLLLLLL","n":["RAQRSQ","add","add_point","borrow","borrow_mut","from","into","new","sum","try_from","try_into","type_id"],"q":[[0,"raq_rsq"]],"d":["","区間加算","1点加算","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","",""],"i":[0,9,9,9,9,9,9,9,9,9,9,9],"f":[0,[[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]],[10,[6]],[0,[1,2,3,4,5,[7,[6]],8]]]],[[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]],6,[0,[1,2,3,4,5,[7,[6]],8]]]],[[]],[[]],[[]],[[]],[[6,[0,[1,2,3,4,5,[7,[6]],8]]],[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]]]],[[[9,[[0,[1,2,3,4,5,[7,[6]],8]]]],[10,[6]]],[[0,[1,2,3,4,5,[7,[6]],8]]]],[[],11],[[],11],[[],12]],"c":[],"p":[[8,"Clone"],[8,"Add"],[8,"AddAssign"],[8,"Sub"],[8,"Neg"],[15,"usize"],[8,"TryFrom"],[8,"Mul"],[3,"RAQRSQ"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"rerooting":{"doc":"全方位木DP …","t":"DLLLLLLLLLL","n":["Rerooting","borrow","borrow_mut","fmt","from","get_ans","into","new","try_from","try_into","type_id"],"q":[[0,"rerooting"]],"d":["","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","モノイド<code>M</code>は<code>add_root</code>…","","",""],"i":[0,5,5,5,5,5,5,5,5,5,5],"f":[0,[[]],[[]],[[[5,[[0,[1,2,3]],[0,[1,4]]]],6],7],[[]],[[[5,[[0,[2,3]],4]],8]],[[]],[[[9,[[9,[8]]]],4],[[5,[[0,[2,3]],4]]]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Debug"],[8,"Monoid"],[8,"Commutative"],[8,"FnMut"],[3,"Rerooting"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"rolling_hash":{"doc":"","t":"DLLLLLLLLLLLLLLLLLLL","n":["RollingHash","borrow","borrow_mut","clone","clone_into","eq","fmt","from","get_base_pow","get_hash","get_prefix_hash","get_random_base","into","is_empty","len","new","to_owned","try_from","try_into","type_id"],"q":[[0,"rolling_hash"]],"d":["…","","","","","","","Returns the argument unchanged.","<code>base^i</code>を返す","部分列<code>s[range]</code>のhash値を返す <code>O(1)</code>","接頭辞のhash値を返す(<code>get_hash(0..i)</code>…","…","Calls <code>U::from(self)</code>.","","","sのrolling hashを構築 <code>O(|s|)</code> …","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,1],2],[[1,3],4],[[]],[[1,5],6],[[1,[7,[5]]],6],[[1,5],6],[[],8],[[]],[1,2],[1,5],[[[9,[8]]],1],[[]],[[],10],[[],10],[[],11]],"c":[],"p":[[3,"RollingHash"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"ModIntMersenne"],[8,"RangeBounds"],[15,"u64"],[4,"Option"],[4,"Result"],[3,"TypeId"]]},\
"rustc_hash":{"doc":"Fast, non-cryptographic hash used by rustc and Firefox.","t":"GGDLLLLLLLLLLLLLLL","n":["FxHashMap","FxHashSet","FxHasher","borrow","borrow_mut","default","finish","from","into","try_from","try_into","type_id","write","write_u16","write_u32","write_u64","write_u8","write_usize"],"q":[[0,"rustc_hash"]],"d":["Type alias for a hashmap using the <code>fx</code> hash algorithm.","Type alias for a hashmap using the <code>fx</code> hash algorithm.","A speedy hash algorithm for use within rustc. The hashmap …","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","",""],"i":[0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,0,0,[[]],[[]],[[],1],[1,2],[[]],[[]],[[],3],[[],3],[[],4],[1],[[1,5]],[[1,6]],[[1,2]],[[1,7]],[[1,8]]],"c":[],"p":[[3,"FxHasher"],[15,"u64"],[4,"Result"],[3,"TypeId"],[15,"u16"],[15,"u32"],[15,"u8"],[15,"usize"]]},\
"sa_lcp_array":{"doc":"","t":"F","n":["add"],"q":[[0,"sa_lcp_array"]],"d":[""],"i":[0],"f":[[[1,1],1]],"c":[],"p":[[15,"usize"]]},\
"scc":{"doc":"有効グラフの強連結成分分解を行います。 …","t":"DLLLLLLLLLLLLLLL","n":["SccGraph","add_edge","borrow","borrow_mut","clone","clone_into","fmt","from","from","into","new","scc","to_owned","try_from","try_into","type_id"],"q":[[0,"scc"]],"d":["","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[1,2,2]],[[]],[[]],[1,1],[[]],[[1,3],4],[[]],[[[5,[[5,[2]]]]],1],[[]],[2,1],[1,[[5,[[5,[2]]]]]],[[]],[[],6],[[],6],[[],7]],"c":[],"p":[[3,"SccGraph"],[15,"usize"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]},\
"segtree":{"doc":"From …","t":"DLLLLLLLLLLLLLLLLLLLL","n":["SegTree","all_prod","borrow","borrow_mut","clone","clone_into","eq","fmt","from","from","get","into","max_right","min_left","new","prod","set","to_owned","try_from","try_into","type_id"],"q":[[0,"segtree"]],"d":["","","","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[[2,[1]]]],[[]],[[]],[[[2,[[0,[3,1]]]]],[[2,[[0,[3,1]]]]]],[[]],[[[2,[[0,[4,1]]]],[2,[[0,[4,1]]]]],5],[[[2,[[0,[6,1]]]],7],8],[[]],[9,[[2,[1]]]],[[[2,[1]],10]],[[]],[[[2,[1]],10,11],10],[[[2,[1]],10,11],10],[10,[[2,[1]]]],[[[2,[1]],[12,[10]]]],[[[2,[1]],10]],[[]],[[],13],[[],13],[[],14]],"c":[],"p":[[8,"Monoid"],[3,"SegTree"],[8,"Clone"],[8,"PartialEq"],[15,"bool"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"Fn"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"segtree_2d_compressed":{"doc":"…","t":"DLLLLLLLLLLLLL","n":["SegTree2DCompressed","add","borrow","borrow_mut","fmt","from","get","into","new","prod","set","try_from","try_into","type_id"],"q":[[0,"segtree_2d_compressed"]],"d":["Tは座標圧縮する型  ","…","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,4,4,4,4,4,4,4,4,4,4,4,4,4],"f":[0,[[[4,[[0,[1,2]],3]],3,3]],[[]],[[]],[[[4,[[0,[5,1,2]],[0,[5,3]]]],6],7],[[]],[[[4,[[0,[1,2]],3]],3,3]],[[]],[[],[[4,[[0,[1,2]],3]]]],[[[4,[[0,[1,2]],3]],[8,[3]],[8,[3]]]],[[[4,[[0,[1,2]],3]],3,3]],[[],9],[[],9],[[],10]],"c":[],"p":[[8,"Monoid"],[8,"Commutative"],[8,"Integral"],[3,"SegTree2DCompressed"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"segtree_2d_dense":{"doc":"内部で2次元配列を持つセグメント木 <code>O(HW)</code>…","t":"DLLLLLLLLLLLLLL","n":["SegTree2DDense","all_prod","borrow","borrow_mut","fmt","from","from","get","into","new","prod","set","try_from","try_into","type_id"],"q":[[0,"segtree_2d_dense"]],"d":["","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,3,3,3,3,3,3,3,3,3,3,3,3,3,3],"f":[0,[[[3,[[0,[1,2]]]]]],[[]],[[]],[[[3,[[0,[4,1,2]]]],5],6],[[]],[[[7,[7]]],[[3,[[0,[1,2]]]]]],[[[3,[[0,[1,2]]]],8,8]],[[]],[[8,8],[[3,[[0,[1,2]]]]]],[[[3,[[0,[1,2]]]],[9,[8]],[9,[8]]]],[[[3,[[0,[1,2]]]],8,8]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Monoid"],[8,"Commutative"],[3,"SegTree2DDense"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"sparse_table":{"doc":"…","t":"DLLLLLLLLLLLLL","n":["SparseTable","borrow","borrow_mut","clone","clone_into","fmt","from","into","new","prod","to_owned","try_from","try_into","type_id"],"q":[[0,"sparse_table"]],"d":["","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<code>O(nlogn)</code>","<code>O(1)</code>","","","",""],"i":[0,3,3,3,3,3,3,3,3,3,3,3,3,3],"f":[0,[[]],[[]],[[[3,[[0,[1,2]]]]],[[3,[[0,[1,2]]]]]],[[]],[[[3,[[0,[4,2]]]],5],6],[[]],[[]],[7,[[3,[2]]]],[[[3,[2]],[9,[8]]]],[[]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Clone"],[8,"IdempotentMonoid"],[3,"SparseTable"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"sparse_table_on_segtree":{"doc":"2D Sparse …","t":"DLLLLLLLLLL","n":["SparseTableOnSegTree","borrow","borrow_mut","fmt","from","into","new","prod","try_from","try_into","type_id"],"q":[[0,"sparse_table_on_segtree"]],"d":["","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<code>O(HWlogH)</code>","<code>O(logH)</code>","","",""],"i":[0,5,5,5,5,5,5,5,5,5,5],"f":[0,[[]],[[]],[[[5,[[0,[1,2,3,4]]]],6],7],[[]],[[]],[[[8,[8]]],[[5,[[0,[2,3,4]]]]]],[[[5,[[0,[2,3,4]]]],[10,[9]],[0,[[10,[9]],4]]]],[[],11],[[],11],[[],12]],"c":[],"p":[[8,"Debug"],[8,"IdempotentMonoid"],[8,"Commutative"],[8,"Clone"],[3,"SparseTableOnSegTree"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"usize"],[8,"RangeBounds"],[4,"Result"],[3,"TypeId"]]},\
"static_modint":{"doc":"","t":"GGDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["ModInt1000000007","ModInt998244353","StaticModInt","add","add_assign","add_assign","borrow","borrow_mut","clone","clone_into","default","div","div_assign","div_assign","eq","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","from_str","hash","into","inv","modulus","modulus","mul","mul_assign","mul_assign","neg","new","new","one","pow","product","raw","raw","sub","sub_assign","sub_assign","sum","to_owned","to_string","try_from","try_into","type_id","value","value","zero"],"q":[[0,"static_modint"]],"d":["","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,0,0,[1,1],[[1,1]],[[1,2]],[[]],[[]],[1,1],[[]],[[],1],[1,1],[[1,1]],[[1,2]],[[1,1],3],[[1,4],5],[[1,4],5],[6,1],[7,1],[8,1],[9,1],[10,1],[11,1],[12,1],[13,1],[14,1],[15,1],[16,1],[[]],[17,1],[18,[[19,[1]]]],[[1,20]],[[]],[1,1],[[],15],[[],15],[1,1],[[1,2]],[[1,1]],[1,1],[2,1],[2,1],[[],1],[[1,16],1],[21,1],[15,1],[15,1],[1,1],[[1,2]],[[1,1]],[21,1],[[]],[[],22],[[],19],[[],19],[[],23],[1,15],[1,15],[[],1]],"c":[],"p":[[3,"StaticModInt"],[8,"RemEuclidU32"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"i16"],[15,"i32"],[15,"isize"],[15,"i8"],[15,"i128"],[15,"u128"],[15,"u8"],[15,"i64"],[15,"usize"],[15,"u32"],[15,"u64"],[15,"u16"],[15,"str"],[4,"Result"],[8,"Hasher"],[8,"Iterator"],[3,"String"],[3,"TypeId"]]},\
"top2":{"doc":"abc345e …","t":"DLLLLLLLLLLLLLLLL","n":["Top2Map","borrow","borrow_mut","clone","clone_into","default","first","fmt","from","insert","into","new","second","to_owned","try_from","try_into","type_id"],"q":[[0,"top2"]],"d":["Top2(大きい順)までのMapを持つ …","","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"f":[0,[[]],[[]],[[[5,[[0,[1,2,3]],[0,[1,4,3]]]]],[[5,[[0,[1,2,3]],[0,[1,4,3]]]]]],[[]],[[],[[5,[[0,[2,3]],[0,[4,3]]]]]],[[[5,[[0,[2,3]],[0,[4,3]]]]],6],[[[5,[[0,[7,2,3]],[0,[7,4,3]]]],8],9],[[]],[[[5,[[0,[2,3]],[0,[4,3]]]],[0,[2,3]],[0,[4,3]]]],[[]],[[],[[5,[[0,[2,3]],[0,[4,3]]]]]],[[[5,[[0,[2,3]],[0,[4,3]]]]],6],[[]],[[],10],[[],10],[[],11]],"c":[],"p":[[8,"Clone"],[8,"Eq"],[8,"Copy"],[8,"Ord"],[3,"Top2Map"],[4,"Option"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"TypeId"]]},\
"union_find":{"doc":"…","t":"DLLLLLLLLLLLLLLLLLLLL","n":["UnionFind","borrow","borrow_mut","clone","clone_into","eq","fmt","from","groups","into","is_empty","leader","len","merge","new","same","size","to_owned","try_from","try_into","type_id"],"q":[[0,"union_find"]],"d":["","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","合併しつつ、合併した集合の代表元を返す","","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,1],2],[[1,3],4],[[]],[1,[[6,[[6,[5]]]]]],[[]],[1,2],[[1,5],5],[1,5],[[1,5,5],5],[5,1],[[1,5,5],2],[[1,5],5],[[]],[[],7],[[],7],[[],8]],"c":[],"p":[[3,"UnionFind"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"usize"],[3,"Vec"],[4,"Result"],[3,"TypeId"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
